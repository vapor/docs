{
    "docs": [
        {
            "location": "/", 
            "text": "Vapor Documentation\n\n\nThis is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.\n\n\nVapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.\n\n\nGetting Started\n\n\nIf this is your first time using Vapor, head to the \nInstallation \n macOS\n section to install Swift and create your first app.\n\n\nIf you already have Vapor installed, check out \nGetting Started \n Hello, world\n.\n\n\nLike Vapor?\n\n\nOur small team works hard to make Vapor awesome (and free). Support the framework by \nstarring Vapor on GitHub\n \nor \ndonating $1 monthly\nit helps us a lot. Thanks!\n\n\nOther Sources\n\n\nHere are some other great places to find information about Vapor.\n\n\n\n\n\n\n\n\nname\n\n\ndescription\n\n\nlink\n\n\n\n\n\n\n\n\n\n\nVapor Slack\n\n\nChat with ~5,000 Vapor developers.\n\n\nvisit \n\n\n\n\n\n\nAPI docs\n\n\nAuto-generated documentation from code comments.\n\n\nvisit \n\n\n\n\n\n\nStack Overflow\n\n\nAsk and answer questions with the \nvapor\n tag.\n\n\nvisit \n\n\n\n\n\n\nSource Code\n\n\nLearn how Vapor works under the hood.\n\n\nvisit \n\n\n\n\n\n\nGitHub Issues\n\n\nReport bugs or request features on GitHub.\n\n\nvisit \n\n\n\n\n\n\n\n\nProviders\n\n\nVapor providers are a convenient way to add functionality to your Vapor projects. \nFor a full list of providers, check out the \nvapor-provider\n tag on GitHub.\n\n\nAuthors\n\n\nTanner Nelson\n, \nLogan Wright\n, \nJoannis Orlandos\n, and the hundreds of members of Vapor.", 
            "title": "Overview"
        }, 
        {
            "location": "/#vapor-documentation", 
            "text": "This is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.  Vapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.", 
            "title": "Vapor Documentation"
        }, 
        {
            "location": "/#getting-started", 
            "text": "If this is your first time using Vapor, head to the  Installation   macOS  section to install Swift and create your first app.  If you already have Vapor installed, check out  Getting Started   Hello, world .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#like-vapor", 
            "text": "Our small team works hard to make Vapor awesome (and free). Support the framework by  starring Vapor on GitHub  \nor  donating $1 monthly it helps us a lot. Thanks!", 
            "title": "Like Vapor?"
        }, 
        {
            "location": "/#other-sources", 
            "text": "Here are some other great places to find information about Vapor.     name  description  link      Vapor Slack  Chat with ~5,000 Vapor developers.  visit     API docs  Auto-generated documentation from code comments.  visit     Stack Overflow  Ask and answer questions with the  vapor  tag.  visit     Source Code  Learn how Vapor works under the hood.  visit     GitHub Issues  Report bugs or request features on GitHub.  visit", 
            "title": "Other Sources"
        }, 
        {
            "location": "/#providers", 
            "text": "Vapor providers are a convenient way to add functionality to your Vapor projects. \nFor a full list of providers, check out the  vapor-provider  tag on GitHub.", 
            "title": "Providers"
        }, 
        {
            "location": "/#authors", 
            "text": "Tanner Nelson ,  Logan Wright ,  Joannis Orlandos , and the hundreds of members of Vapor.", 
            "title": "Authors"
        }, 
        {
            "location": "/installation/install-on-macos/", 
            "text": "Install on macOS\n\n\nIf you're on a Mac, you can develop your Vapor 3 project using Xcode 9 or greater.\nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.\n\n\n\n\nTo use Vapor on macOS, you just need to have Xcode 9 or greater installed.\n\n\nInstall Xcode\n\n\nInstall \nXcode 9 or greater\n from the Mac App Store.\n\n\n\n\nOpen Xcode\n\n\nAfter Xcode has been downloaded, you must open it to finish the installation. This may take a while.\n\n\nVerify Swift Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\neval\n \n$(\ncurl -sL check.vapor.sh\n)\n\n\n\n\n\n\nInstall Vapor\n\n\nNow that you have Swift 4, let's install the Vapor toolbox.\n\n\nThe toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.\n\n\nInstall Homebrew\n\n\nIf you don't already have Homebrew installed, install it! It's incredibly useful for installing software dependencies like MySQL, Postgres, MongoDB, Redis and more.\n\n\n/usr/bin/ruby -e \n$(\ncurl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install\n)\n\n\n\n\n\n\nFor more information on installing Homebrew, visit \nbrew.sh\n.\n\n\nAdd Homebrew Tap\n\n\nVapor's Homebrew tap will give your Homebrew installation access to all of Vapor's macOS packages.\n\n\nbrew tap vapor/homebrew-tap\nbrew update\n\n\n\n\n\nInstall\n\n\nNow that you've added Vapor's tap, you can install Vapor's toolbox and dependencies.\n\n\nbrew install vapor\n\n\n\n\n\nNext\n\n\nWe have more detailed information about managing your project and dependencies \nhere\n.", 
            "title": "Install: macOS"
        }, 
        {
            "location": "/installation/install-on-macos/#install-on-macos", 
            "text": "If you're on a Mac, you can develop your Vapor 3 project using Xcode 9 or greater.\nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.   To use Vapor on macOS, you just need to have Xcode 9 or greater installed.", 
            "title": "Install on macOS"
        }, 
        {
            "location": "/installation/install-on-macos/#install-xcode", 
            "text": "Install  Xcode 9 or greater  from the Mac App Store.", 
            "title": "Install Xcode"
        }, 
        {
            "location": "/installation/install-on-macos/#open-xcode", 
            "text": "After Xcode has been downloaded, you must open it to finish the installation. This may take a while.", 
            "title": "Open Xcode"
        }, 
        {
            "location": "/installation/install-on-macos/#verify-swift-installation", 
            "text": "Double check the installation was successful by opening Terminal and running:  eval   $( curl -sL check.vapor.sh )", 
            "title": "Verify Swift Installation"
        }, 
        {
            "location": "/installation/install-on-macos/#install-vapor", 
            "text": "Now that you have Swift 4, let's install the Vapor toolbox.  The toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/installation/install-on-macos/#install-homebrew", 
            "text": "If you don't already have Homebrew installed, install it! It's incredibly useful for installing software dependencies like MySQL, Postgres, MongoDB, Redis and more.  /usr/bin/ruby -e  $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install )   For more information on installing Homebrew, visit  brew.sh .", 
            "title": "Install Homebrew"
        }, 
        {
            "location": "/installation/install-on-macos/#add-homebrew-tap", 
            "text": "Vapor's Homebrew tap will give your Homebrew installation access to all of Vapor's macOS packages.  brew tap vapor/homebrew-tap\nbrew update", 
            "title": "Add Homebrew Tap"
        }, 
        {
            "location": "/installation/install-on-macos/#install", 
            "text": "Now that you've added Vapor's tap, you can install Vapor's toolbox and dependencies.  brew install vapor", 
            "title": "Install"
        }, 
        {
            "location": "/installation/install-on-macos/#next", 
            "text": "We have more detailed information about managing your project and dependencies  here .", 
            "title": "Next"
        }, 
        {
            "location": "/installation/install-on-ubuntu/", 
            "text": "Install on Ubuntu\n\n\nInstalling Vapor on Ubuntu only takes a couple of minutes.\n\n\nSupported\n\n\nVapor supports the same versions of Ubuntu that Swift supports.\n\n\n\n\n\n\n\n\nVersion\n\n\nCodename\n\n\n\n\n\n\n\n\n\n\n16.10\n\n\nYakkety Yak\n\n\n\n\n\n\n16.04\n\n\nXenial Xerus\n\n\n\n\n\n\n14.04\n\n\nTrusty Tahr\n\n\n\n\n\n\n\n\nAPT Repo\n\n\nAdd Vapor's APT repo to get access to all of Vapor's system packages.\n\n\nQuick Script\n\n\nEasily add Vapor's APT repo with this handy script.\n\n\neval\n \n$(\ncurl -sL https://apt.vapor.sh\n)\n\n\n\n\n\n\n\n\nNote\n\n\nThis command requires \ncurl\n which can be installed using \nsudo apt-get install curl\n\n\n\n\nDockerfile\n\n\nWhen configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:\n\n\n    RUN /bin/bash -c \n$(\nwget -qO- https://apt.vapor.sh\n)\n\n\n\n\n\n\nManual\n\n\nOr add the repo manually.\n\n\nwget -q https://repo.vapor.codes/apt/keyring.gpg -O- \n|\n sudo apt-key add -\n\necho\n \ndeb https://repo.vapor.codes/apt \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update\n\n\n\n\n\nInstall Vapor\n\n\nNow that you have added Vapor's APT repo, you can install the required dependencies.\n\n\nsudo apt-get install swift vapor\n\n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by running:\n\n\neval\n \n$(\ncurl -sL check.vapor.sh\n)\n\n\n\n\n\n\nNext\n\n\nLearn more about the Vapor toolbox CLI in the \nToolbox section\n of the Getting Started section.\n\n\nSwift.org\n\n\nCheck out \nSwift.org\n's guide to \nusing downloads\n if you need more detailed instructions for installing Swift 4.", 
            "title": "Install: Ubuntu"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#install-on-ubuntu", 
            "text": "Installing Vapor on Ubuntu only takes a couple of minutes.", 
            "title": "Install on Ubuntu"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#supported", 
            "text": "Vapor supports the same versions of Ubuntu that Swift supports.     Version  Codename      16.10  Yakkety Yak    16.04  Xenial Xerus    14.04  Trusty Tahr", 
            "title": "Supported"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#apt-repo", 
            "text": "Add Vapor's APT repo to get access to all of Vapor's system packages.", 
            "title": "APT Repo"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#quick-script", 
            "text": "Easily add Vapor's APT repo with this handy script.  eval   $( curl -sL https://apt.vapor.sh )    Note  This command requires  curl  which can be installed using  sudo apt-get install curl", 
            "title": "Quick Script"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#dockerfile", 
            "text": "When configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:      RUN /bin/bash -c  $( wget -qO- https://apt.vapor.sh )", 
            "title": "Dockerfile"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#manual", 
            "text": "Or add the repo manually.  wget -q https://repo.vapor.codes/apt/keyring.gpg -O-  |  sudo apt-key add - echo   deb https://repo.vapor.codes/apt  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update", 
            "title": "Manual"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#install-vapor", 
            "text": "Now that you have added Vapor's APT repo, you can install the required dependencies.  sudo apt-get install swift vapor", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#verify-installation", 
            "text": "Double check the installation was successful by running:  eval   $( curl -sL check.vapor.sh )", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#next", 
            "text": "Learn more about the Vapor toolbox CLI in the  Toolbox section  of the Getting Started section.", 
            "title": "Next"
        }, 
        {
            "location": "/installation/install-on-ubuntu/#swiftorg", 
            "text": "Check out  Swift.org 's guide to  using downloads  if you need more detailed instructions for installing Swift 4.", 
            "title": "Swift.org"
        }, 
        {
            "location": "/installation/toolbox/", 
            "text": "Install Toolbox\n\n\nVapor's command line interface provides shortcuts and assistance for common tasks.\n\n\n\n\n\n\nTip\n\n\nIf you do not want to use the Toolbox or templates, checkout the \nManual\n quickstart.\n\n\n\n\nHelp\n\n\nHelp prints useful information about available commands and flags. You can also run the \n--help\n option on any Toolbox command.\n\n\nvapor --help\n\n\n\n\n\nApplication Commands\n\n\nThe \nvapor run\n command is a special toolbox command that forwards to your Vapor application.\n\n\nYou can use \nvapor run serve\n to boot your application, or \nvapor run help\n to view all available application-level commands. This includes custom commands you may have added to your application.\n\n\n\n\nWarning\n\n\nUsing \nvapor run --help\n will provide information about the \nrun\n command itself and will not forward to your Vapor application.\n\n\n\n\nUpdating\n\n\nThe toolbox should be updated by the package manager it was installed with.\n\n\nHomebrew\n\n\nbrew upgrade vapor\n\n\n\n\n\nAPT\n\n\nsudo apt-get update\nsudo apt-get install vapor\n\n\n\n\n\nTemplates\n\n\nThe toolbox can create a project from the Vapor basic-template or any other git repo.\n\n\nvapor new \nname\n \n[\n--template\n]\n\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAPI\n\n\n--template=api\n\n\nJSON API with Fluent database.\n\n\n\n\n\n\nWeb\n\n\n--template=web\n\n\nHTML website with Leaf templates.\n\n\n\n\n\n\n\n\nView a list of all \ntemplates\n on GitHub.\n\n\n\n\nNote\n\n\nIf you do not specify a template option, the API template will be used.\nThis may change in the future.\n\n\n\n\nOptions\n\n\nThe toolbox will build an absolute URL based on what you pass as the template option.\n\n\n\n\n--template=web\n clones \nhttp://github.com/vapor/web-template\n\n\n--template=user/repo\n clones \nhttp://github.com/user/repo\n.\n\n\n--template=http://example.com/repo-path\n clones the full url given.\n\n\n--branch=foo\n can be used to specify a branch besides \nmaster\n.", 
            "title": "Toolbox"
        }, 
        {
            "location": "/installation/toolbox/#install-toolbox", 
            "text": "Vapor's command line interface provides shortcuts and assistance for common tasks.    Tip  If you do not want to use the Toolbox or templates, checkout the  Manual  quickstart.", 
            "title": "Install Toolbox"
        }, 
        {
            "location": "/installation/toolbox/#help", 
            "text": "Help prints useful information about available commands and flags. You can also run the  --help  option on any Toolbox command.  vapor --help", 
            "title": "Help"
        }, 
        {
            "location": "/installation/toolbox/#application-commands", 
            "text": "The  vapor run  command is a special toolbox command that forwards to your Vapor application.  You can use  vapor run serve  to boot your application, or  vapor run help  to view all available application-level commands. This includes custom commands you may have added to your application.   Warning  Using  vapor run --help  will provide information about the  run  command itself and will not forward to your Vapor application.", 
            "title": "Application Commands"
        }, 
        {
            "location": "/installation/toolbox/#updating", 
            "text": "The toolbox should be updated by the package manager it was installed with.", 
            "title": "Updating"
        }, 
        {
            "location": "/installation/toolbox/#homebrew", 
            "text": "brew upgrade vapor", 
            "title": "Homebrew"
        }, 
        {
            "location": "/installation/toolbox/#apt", 
            "text": "sudo apt-get update\nsudo apt-get install vapor", 
            "title": "APT"
        }, 
        {
            "location": "/installation/toolbox/#templates", 
            "text": "The toolbox can create a project from the Vapor basic-template or any other git repo.  vapor new  name   [ --template ]      Name  Flag  Description      API  --template=api  JSON API with Fluent database.    Web  --template=web  HTML website with Leaf templates.     View a list of all  templates  on GitHub.   Note  If you do not specify a template option, the API template will be used.\nThis may change in the future.", 
            "title": "Templates"
        }, 
        {
            "location": "/installation/toolbox/#options", 
            "text": "The toolbox will build an absolute URL based on what you pass as the template option.   --template=web  clones  http://github.com/vapor/web-template  --template=user/repo  clones  http://github.com/user/repo .  --template=http://example.com/repo-path  clones the full url given.  --branch=foo  can be used to specify a branch besides  master .", 
            "title": "Options"
        }, 
        {
            "location": "/installation/package/", 
            "text": "Managing your project\n\n\nIn Server Side Swift, the SPM (Swift Package Manager) is used for managing your project and it's dependencies. At the heart of your project is the \nPackage.swift\n file. This is a file that's written in Swift and is used for defining the dependencies, target projects and other aspects of your project. All of this is expressed in Swift.\n\n\nGenerate Project\n\n\nTo use Xcode, you will first need to generate a \n*.xcodeproj\n file.\n\n\nVapor Toolbox\n\n\nTo generate a new Xcode project for a project, use:\n\n\nvapor xcode\n\n\n\n\n\n\n\nTip\n\n\nIf you'd like to automatically open the Xcode project, use \nvapor xcode -y\n\n\n\n\nSelect 'Run'\n\n\nMake sure after generating your Xcode project that you properly select the executable if you're trying to run your application.\n\n\n\n\nManual\n\n\nTo generate a new Xcode project manually.\n\n\nswift package generate-xcodeproj\n\n\n\n\n\nOpen the project and continue normally.\n\n\nChanging dependencies\n\n\nTo change dependencies you need to add your \nPackage.swift\n file in the root of your project. The dependency should specify what needs to be added/changed in their readme or documentation.\n\n\nAfter changing your \nPackage.swift\n file you'll need to instruct Vapor Toolbox or SPM to update your dependencies.\n\n\nVapor Toolbox\n\n\nThe first step is to update your dependencies.\n\n\nvapor update\n\n\n\n\n\nAfter changing the dependencies you will have to update your xcode project as well.\n\n\nvapor xcode\n\n\n\n\n\nManual\n\n\nTo manually update your dependencies\n\n\nswift package update\n\n\n\n\n\nAfter updating, you'll need to update your xcode project as well.\n\n\nswift\n \npackge\n \ngenerate\n-\nxcodeproj\n\n\n\n\n\n\nTroubleshooting\n\n\nIf you're experiencing issues (after) updating you should try cleaning the project and updating the dependencies.\n\n\nVapor Toolbox\n\n\nvapor clean\n\n\n\n\n\nManual\n\n\nswift package clean", 
            "title": "Xcode & SPM"
        }, 
        {
            "location": "/installation/package/#managing-your-project", 
            "text": "In Server Side Swift, the SPM (Swift Package Manager) is used for managing your project and it's dependencies. At the heart of your project is the  Package.swift  file. This is a file that's written in Swift and is used for defining the dependencies, target projects and other aspects of your project. All of this is expressed in Swift.", 
            "title": "Managing your project"
        }, 
        {
            "location": "/installation/package/#generate-project", 
            "text": "To use Xcode, you will first need to generate a  *.xcodeproj  file.", 
            "title": "Generate Project"
        }, 
        {
            "location": "/installation/package/#vapor-toolbox", 
            "text": "To generate a new Xcode project for a project, use:  vapor xcode   Tip  If you'd like to automatically open the Xcode project, use  vapor xcode -y", 
            "title": "Vapor Toolbox"
        }, 
        {
            "location": "/installation/package/#select-run", 
            "text": "Make sure after generating your Xcode project that you properly select the executable if you're trying to run your application.", 
            "title": "Select 'Run'"
        }, 
        {
            "location": "/installation/package/#manual", 
            "text": "To generate a new Xcode project manually.  swift package generate-xcodeproj  Open the project and continue normally.", 
            "title": "Manual"
        }, 
        {
            "location": "/installation/package/#changing-dependencies", 
            "text": "To change dependencies you need to add your  Package.swift  file in the root of your project. The dependency should specify what needs to be added/changed in their readme or documentation.  After changing your  Package.swift  file you'll need to instruct Vapor Toolbox or SPM to update your dependencies.", 
            "title": "Changing dependencies"
        }, 
        {
            "location": "/installation/package/#vapor-toolbox_1", 
            "text": "The first step is to update your dependencies.  vapor update  After changing the dependencies you will have to update your xcode project as well.  vapor xcode", 
            "title": "Vapor Toolbox"
        }, 
        {
            "location": "/installation/package/#manual_1", 
            "text": "To manually update your dependencies  swift package update  After updating, you'll need to update your xcode project as well.  swift   packge   generate - xcodeproj", 
            "title": "Manual"
        }, 
        {
            "location": "/installation/package/#troubleshooting", 
            "text": "If you're experiencing issues (after) updating you should try cleaning the project and updating the dependencies.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/installation/package/#vapor-toolbox_2", 
            "text": "vapor clean", 
            "title": "Vapor Toolbox"
        }, 
        {
            "location": "/installation/package/#manual_2", 
            "text": "swift package clean", 
            "title": "Manual"
        }, 
        {
            "location": "/getting-started/hello-world/", 
            "text": "Hello, world\n\n\nTODO", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#hello-world", 
            "text": "TODO", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/structure/", 
            "text": "Structure\n\n\nTODO: talk about the structure of vapor applications including folder, module, etc", 
            "title": "Structure"
        }, 
        {
            "location": "/getting-started/structure/#structure", 
            "text": "TODO: talk about the structure of vapor applications including folder, module, etc", 
            "title": "Structure"
        }, 
        {
            "location": "/getting-started/application/", 
            "text": "Application\n\n\nEvery application in Vapor starts as an \nApplication\n. Application is a open class, meaning it \ncan\n be subclassed to add extra properties, but that's usually not necessary.\n\n\nApplication has a \nConfig\n and \nServices\n.\n\n\nApplication may behave differently depending on it's \nEnvironment\n.\n\n\nCreating a basic application\n\n\nIf not overridden, \nApplication\n comes with it's own set of default services. This makes setting up an empty (basic) application extremely simple.\n\n\nimport\n \nVapor\n\n\n\nlet\n \napplication\n \n=\n \nApplication\n()\n\n\n\n// Set up your routes etc..\n\n\n\ntry\n \napplication\n.\nrun\n()\n\n\n\n\n\n\nYou can override the default config, environment and services like so:\n\n\nlet\n \nconfig\n:\n \nConfig\n \n=\n \n...\n\n\nlet\n \nenvironment\n \n=\n \nEnvironment\n.\nproduction\n\n\nvar\n \nservices\n \n=\n \nServices\n.\ndefault\n()\n\n\n\n// configure services, otherwise there\ns no Server and Router\n\n\n\n\n\n\nApplication routing services\n\n\nIn order to add routes to an \nApplication\n you need to get a router first.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \napp\n.\nmake\n(\nRouter\n.\nself\n)\n\n\n\n\n\n\nFrom here you can start writing \nyour application's routes\n.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#application", 
            "text": "Every application in Vapor starts as an  Application . Application is a open class, meaning it  can  be subclassed to add extra properties, but that's usually not necessary.  Application has a  Config  and  Services .  Application may behave differently depending on it's  Environment .", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#creating-a-basic-application", 
            "text": "If not overridden,  Application  comes with it's own set of default services. This makes setting up an empty (basic) application extremely simple.  import   Vapor  let   application   =   Application ()  // Set up your routes etc..  try   application . run ()   You can override the default config, environment and services like so:  let   config :   Config   =   ...  let   environment   =   Environment . production  var   services   =   Services . default ()  // configure services, otherwise there s no Server and Router", 
            "title": "Creating a basic application"
        }, 
        {
            "location": "/getting-started/application/#application-routing-services", 
            "text": "In order to add routes to an  Application  you need to get a router first.  let   router   =   try   app . make ( Router . self )   From here you can start writing  your application's routes .", 
            "title": "Application routing services"
        }, 
        {
            "location": "/getting-started/promises/", 
            "text": "Introduction into Promises and Futures\n\n\nWhen working with asynchronous APIs, one of the problems you'll face is not knowing when a variable is set.\n\n\nWhen querying a database synchronously, the thread is blocked until a result has been received. At which point the result will be returned to you and the thread continues from where you left off querying the database.\n\n\nlet\n \nuser\n \n=\n \ntry\n \ndatabase\n.\nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\nprint\n(\nuser\n.\nusername\n)\n\n\n\n\n\n\nIn the asynchronous world, you won't receive a result immediately. Instead, you'll receive a result in a callback.\n\n\n// Callback `found` will receive the user. If an error occurred, the `onError` callback will be called instead.\n\n\ntry\n \ndatabase\n.\nfetchUser\n(\nnamed\n:\n \nAdmin\n,\n \nfound\n:\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n},\n \nonError\n:\n \n{\n \nerror\n \nin\n\n  \nprint\n(\nerror\n)\n\n\n})\n\n\n\n\n\n\nYou can imagine code becoming complex. Difficult to read and comprehend.\n\n\nPromises and futures are two types that this library introduces to solve this.\n\n\nCreating a promise\n\n\nPromises are important if you're implementing a function that returns a result in the future, such as the database shown above.\n\n\nPromises need to be created without a result. They can then be completed with the expectation or an error at any point.\n\n\nYou can extract a \nfuture\n from the \npromise\n that you can hand to the API consumer.\n\n\n// the example `fetchUser` implementation\n\n\nfunc\n \nfetchUser\n(\nnamed\n \nname\n:\n \nString\n)\n \n-\n \nFuture\nUser\n \n{\n\n    \n// Creates a promise that can be fulfilled in the future\n\n    \nlet\n \npromise\n \n=\n \nPromise\nUser\n()\n\n\n    \ndo\n \n{\n\n    \n// \nTODO:\n Run a query asynchronously, looking for the user\n\n\n        \n// Initialize the user using the datbase result\n\n        \n// This can throw an error if the result is empty or invalid\n\n        \nlet\n \nuser\n \n=\n \ntry\n \nUser\n(\ndecodingFrom\n:\n \ndatabaseResult\n)\n\n\n        \n// If initialization is successful, complete the promise.\n\n        \n//\n\n        \n// Completing the promise will notify the promise\ns associated future with this user\n\n        \npromise\n.\ncomplete\n(\nuser\n)\n\n    \n}\n \ncatch\n \n{\n\n        \n// If initialization is successful, fail the promise.\n\n        \n//\n\n        \n// Failing the promise will notify the promise\ns associated future with an error\n\n        \npromise\n.\nfail\n(\nerror\n)\n\n    \n}\n\n\n    \n// After spawning the asynchronous operation, return the promise\ns associated future\n\n    \n//\n\n    \n// The future can then be used by the API consumer\n\n    \nreturn\n \npromise\n.\nfuture\n\n\n}\n\n\n\n\n\n\nOn future completion\n\n\nWhen a promise completes, you can chain the result/error into a closure:\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// `.then`\ns closure will be executed on success\n\n\nfuture\n.\nthen\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n// `.catch` will catch any error on failure\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n  \nprint\n(\nerror\n)\n\n\n}\n\n\n\n\n\n\nCatching specific errors\n\n\nSometimes you only care for specific errors, for example, for logging.\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// `.then`\ns closure will be executed on success\n\n\nfuture\n.\nthen\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n// This `.catch` will only catch `DatabaseError`s\n\n\n}.\ncatch\n(\nDatabaseError\n.\nself\n)\n \n{\n \ndatabaseError\n \nin\n\n    \nprint\n(\ndatabaseError\n)\n\n\n// `.catch` will catch any error on failure, including `DatabaseError` types\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n  \nprint\n(\nerror\n)\n\n\n}\n\n\n\n\n\n\nMapping results\n\n\nFutures can be mapped to different results asynchronously.\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// Maps the user to it\ns username\n\n\nlet\n \nfutureUsername\n:\n \nFuture\nString\n \n=\n \nfuture\n.\nmap\n \n{\n \nuser\n \nin\n\n    \nreturn\n \nuser\n.\nusername\n\n\n}\n\n\n\n// Mapped futures can be mapped and chained, too\n\n\nfutureUsername\n.\nthen\n \n{\n \nusername\n \nin\n\n    \nprint\n(\nusername\n)\n\n\n}\n\n\n\n\n\n\nFutures without promise\n\n\nIn some scenarios you're required to return a \nFuture\n where a \nPromise\n isn't necessary as you already have the result.\n\n\nIn these scenarios you can initialize a future with the already completed result.\n\n\n// Already completed on initialization\n\n\nlet\n \nfuture\n \n=\n \nFuture\n(\nHello world!\n)\n\n\n\nfuture\n.\nthen\n \n{\n \nstring\n \nin\n\n  \nprint\n(\nstring\n)\n\n\n}\n\n\n\n\n\n\nSynchronous APIs\n\n\nSometimes, an API needs to be used synchronously in a synchronous envinronment.\n\n\nRather than using a synchronous API with all edge cases involved, we recommend using the \ntry future.blockingAwait()\n function.\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// This will either receive the user if the promise was completed or throw an error if the promise was failed.\n\n\nlet\n \nuser\n:\n \nUser\n \n=\n \ntry\n \nfuture\n.\nblockingAwait\n()\n\n\n\n\n\n\nThis will wait for a result indefinitely, blocking the thread.\n\n\nIf you expect a result with a specified duration, say, 30 seconds:\n\n\n// This will also throw an error if the deadline wasn\nt met\n\n\nlet\n \nuser\n \n=\n \ntry\n \nfuture\n.\nblocked\n(\ntimeout\n:\n \n.\nseconds\n(\n30\n))", 
            "title": "Promises"
        }, 
        {
            "location": "/getting-started/promises/#introduction-into-promises-and-futures", 
            "text": "When working with asynchronous APIs, one of the problems you'll face is not knowing when a variable is set.  When querying a database synchronously, the thread is blocked until a result has been received. At which point the result will be returned to you and the thread continues from where you left off querying the database.  let   user   =   try   database . fetchUser ( named :   Admin )  print ( user . username )   In the asynchronous world, you won't receive a result immediately. Instead, you'll receive a result in a callback.  // Callback `found` will receive the user. If an error occurred, the `onError` callback will be called instead.  try   database . fetchUser ( named :   Admin ,   found :   {   user   in \n   print ( user . username )  },   onError :   {   error   in \n   print ( error )  })   You can imagine code becoming complex. Difficult to read and comprehend.  Promises and futures are two types that this library introduces to solve this.", 
            "title": "Introduction into Promises and Futures"
        }, 
        {
            "location": "/getting-started/promises/#creating-a-promise", 
            "text": "Promises are important if you're implementing a function that returns a result in the future, such as the database shown above.  Promises need to be created without a result. They can then be completed with the expectation or an error at any point.  You can extract a  future  from the  promise  that you can hand to the API consumer.  // the example `fetchUser` implementation  func   fetchUser ( named   name :   String )   -   Future User   { \n     // Creates a promise that can be fulfilled in the future \n     let   promise   =   Promise User () \n\n     do   { \n     //  TODO:  Run a query asynchronously, looking for the user \n\n         // Initialize the user using the datbase result \n         // This can throw an error if the result is empty or invalid \n         let   user   =   try   User ( decodingFrom :   databaseResult ) \n\n         // If initialization is successful, complete the promise. \n         // \n         // Completing the promise will notify the promise s associated future with this user \n         promise . complete ( user ) \n     }   catch   { \n         // If initialization is successful, fail the promise. \n         // \n         // Failing the promise will notify the promise s associated future with an error \n         promise . fail ( error ) \n     } \n\n     // After spawning the asynchronous operation, return the promise s associated future \n     // \n     // The future can then be used by the API consumer \n     return   promise . future  }", 
            "title": "Creating a promise"
        }, 
        {
            "location": "/getting-started/promises/#on-future-completion", 
            "text": "When a promise completes, you can chain the result/error into a closure:  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // `.then` s closure will be executed on success  future . then   {   user   in \n   print ( user . username )  // `.catch` will catch any error on failure  }. catch   {   error   in \n   print ( error )  }", 
            "title": "On future completion"
        }, 
        {
            "location": "/getting-started/promises/#catching-specific-errors", 
            "text": "Sometimes you only care for specific errors, for example, for logging.  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // `.then` s closure will be executed on success  future . then   {   user   in \n   print ( user . username )  // This `.catch` will only catch `DatabaseError`s  }. catch ( DatabaseError . self )   {   databaseError   in \n     print ( databaseError )  // `.catch` will catch any error on failure, including `DatabaseError` types  }. catch   {   error   in \n   print ( error )  }", 
            "title": "Catching specific errors"
        }, 
        {
            "location": "/getting-started/promises/#mapping-results", 
            "text": "Futures can be mapped to different results asynchronously.  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // Maps the user to it s username  let   futureUsername :   Future String   =   future . map   {   user   in \n     return   user . username  }  // Mapped futures can be mapped and chained, too  futureUsername . then   {   username   in \n     print ( username )  }", 
            "title": "Mapping results"
        }, 
        {
            "location": "/getting-started/promises/#futures-without-promise", 
            "text": "In some scenarios you're required to return a  Future  where a  Promise  isn't necessary as you already have the result.  In these scenarios you can initialize a future with the already completed result.  // Already completed on initialization  let   future   =   Future ( Hello world! )  future . then   {   string   in \n   print ( string )  }", 
            "title": "Futures without promise"
        }, 
        {
            "location": "/getting-started/promises/#synchronous-apis", 
            "text": "Sometimes, an API needs to be used synchronously in a synchronous envinronment.  Rather than using a synchronous API with all edge cases involved, we recommend using the  try future.blockingAwait()  function.  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // This will either receive the user if the promise was completed or throw an error if the promise was failed.  let   user :   User   =   try   future . blockingAwait ()   This will wait for a result indefinitely, blocking the thread.  If you expect a result with a specified duration, say, 30 seconds:  // This will also throw an error if the deadline wasn t met  let   user   =   try   future . blocked ( timeout :   . seconds ( 30 ))", 
            "title": "Synchronous APIs"
        }, 
        {
            "location": "/getting-started/routing/", 
            "text": "Routing\n\n\nIn Vapor, routing is usually done using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands. You can provide \ncustom (flexible) parameters\n or normal literal string path components to express the path.\n\n\nCreating a router\n\n\nTo register routes, first, you need to get a router object.\n\n\nTo access some routing functions you may need to \nimport Routing\n.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \napp\n.\nmake\n(\nRouter\n.\nself\n)\n\n\n\n\n\n\nThis router can then be used to register routes. However, you should only register routes during the setup phase of your application. Registering routes during the execution of Vapor \ncould\n cause a crash.\n\n\nRegistering routes\n\n\nRegistering routes using the shorthands requires a \nRouter\n. To work with \nRequest\n and \nResponse\n objects you should \nimport HTTP\n.\n\n\nrouter\n.\nget\n(\nusers\n)\n \n{\n \nrequest\n \nin\n\n    \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}\n\n\n\n\n\n\nWe created a \nGET\n route to \n/users/\n. The \nrequest\n that is accepted in the trailing closure can be used to access all request metadata.\n\n\nThe \nResponse\n returned will then be sent to the client.\n\n\nThe returned response in this closure \nmust\n be either a \nResponse\n or a \nFuture\n containing any \nResponseRepresentable\n.\n\n\nRegistering with parameters\n\n\nTODO", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#routing", 
            "text": "In Vapor, routing is usually done using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands. You can provide  custom (flexible) parameters  or normal literal string path components to express the path.", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#creating-a-router", 
            "text": "To register routes, first, you need to get a router object.  To access some routing functions you may need to  import Routing .  let   router   =   try   app . make ( Router . self )   This router can then be used to register routes. However, you should only register routes during the setup phase of your application. Registering routes during the execution of Vapor  could  cause a crash.", 
            "title": "Creating a router"
        }, 
        {
            "location": "/getting-started/routing/#registering-routes", 
            "text": "Registering routes using the shorthands requires a  Router . To work with  Request  and  Response  objects you should  import HTTP .  router . get ( users )   {   request   in \n     return   Response ( status :   . ok )  }   We created a  GET  route to  /users/ . The  request  that is accepted in the trailing closure can be used to access all request metadata.  The  Response  returned will then be sent to the client.  The returned response in this closure  must  be either a  Response  or a  Future  containing any  ResponseRepresentable .", 
            "title": "Registering routes"
        }, 
        {
            "location": "/getting-started/routing/#registering-with-parameters", 
            "text": "TODO", 
            "title": "Registering with parameters"
        }, 
        {
            "location": "/getting-started/json/", 
            "text": "JSON\n\n\nVapor doesn't recommend using a \"raw\" JSON API. We instead recommend using \nFoundation.JSONEncoder\n and \nFoundation.JSONDecoder\n for type-safe JSON communication.\n\n\nThis requires you to \nimport Foundation\n when working with JSON.\n\n\nLogin screen Example\n\n\nFor the purpose of a demo this example does not use \npassword hashing/encryption\n or a \ndatabase\n.\n\n\nThe raw data\n\n\nFirst, create the models for the JSON requests, responses, errors and the underlying (internal) data structure.\n\n\n/// The model, can be stored in the database\n\n\nclass\n \nUser\n:\n \nCodable\n \n{\n\n  \n/// The profile of this user, containing public information\n\n  \nstruct\n \nProfile\n:\n \nCodable\n \n{\n\n    \nvar\n \nfirstName\n:\n \nString\n\n    \nvar\n \nlastName\n:\n \nString\n\n  \n}\n\n\n  \nvar\n \nprofile\n:\n \nProfile\n\n  \nvar\n \nemail\n:\n \nString\n\n  \nvar\n \npassword\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThe models must be formatted according to the expected input/output in JSON.\n\n\n/// A Login request (input)\n\n\n/// Requires an email address and a password\n\n\nstruct\n \nLoginRequest\n:\n \nDecodable\n \n{\n\n  \nvar\n \nemail\n:\n \nString\n\n  \nvar\n \npassword\n:\n \nString\n\n\n}\n\n\n\n/// A login response (success output)\n\n\nstruct\n \nLoginResponse\n:\n \nEncodable\n,\n \nResponseRepresentable\n \n{\n\n  \nvar\n \ntoken\n:\n \nString\n\n\n  \n// The profile will be encoded to JSON\n\n  \nvar\n \nuser\n:\n \nUser\n.\nProfile\n\n\n}\n\n\n\n/// A login error (unsuccessful output)\n\n\nstruct\n \nLoginError\n:\n \nEncodable\n,\n \nResponseRepresentable\n \n{\n\n  \n// The reason will be represented in JSON as a `String`\n\n  \nenum\n \nReason\n:\n \nString\n,\n \nEncodable\n \n{\n\n    \ncase\n \ninvalidCredentials\n\n    \ncase\n \naccountSuspended\n\n  \n}\n\n\n  \nvar\n \nreason\n:\n \nReason\n\n\n}\n\n\n\n\n\n\nDecoding the Request\n\n\nRequest\n has a \nBody\n that will need to be decoded using Foundation's \nJSONDecoder\n.\n\n\nlet\n \nloginRequest\n \n=\n \ntry\n \nJSONDecoder\n().\ndecode\n(\nLoginRequest\n.\nself\n,\n \nfrom\n:\n \nrequest\n.\nbody\n.\ndata\n)\n\n\n\n\n\n\nThe result is a type-safe instantiation of the login request.\n\n\n{\n\n  \nemail\n:\n \ntest@example.com\n,\n\n  \npassword\n:\n \nhunter2\n\n\n}\n\n\n\n\n\n\nDecoding the above using the \nJSONDecoder\n will result in the following \nloginRequest\n.\n\n\nprint\n(\nloginRequest\n.\nemail\n)\n \n// prints \ntest@example.com\n\n\nprint\n(\nloginRequest\n.\npassword\n)\n \n// prints \nhunter2\n\n\n\n\n\n\nEncoding an (error) response\n\n\nFirst you need to instantiate your \nResponseRepresentable\n response.\n\n\nReturning this from a \nRoute\n will convert it to a \nResponse\n automatically.\n\n\nreturn\n \nLoginError\n(\nreason\n:\n \n.\ninvalidCredentials\n)", 
            "title": "JSON"
        }, 
        {
            "location": "/getting-started/json/#json", 
            "text": "Vapor doesn't recommend using a \"raw\" JSON API. We instead recommend using  Foundation.JSONEncoder  and  Foundation.JSONDecoder  for type-safe JSON communication.  This requires you to  import Foundation  when working with JSON.", 
            "title": "JSON"
        }, 
        {
            "location": "/getting-started/json/#login-screen-example", 
            "text": "For the purpose of a demo this example does not use  password hashing/encryption  or a  database .", 
            "title": "Login screen Example"
        }, 
        {
            "location": "/getting-started/json/#the-raw-data", 
            "text": "First, create the models for the JSON requests, responses, errors and the underlying (internal) data structure.  /// The model, can be stored in the database  class   User :   Codable   { \n   /// The profile of this user, containing public information \n   struct   Profile :   Codable   { \n     var   firstName :   String \n     var   lastName :   String \n   } \n\n   var   profile :   Profile \n   var   email :   String \n   var   password :   String  }   The models must be formatted according to the expected input/output in JSON.  /// A Login request (input)  /// Requires an email address and a password  struct   LoginRequest :   Decodable   { \n   var   email :   String \n   var   password :   String  }  /// A login response (success output)  struct   LoginResponse :   Encodable ,   ResponseRepresentable   { \n   var   token :   String \n\n   // The profile will be encoded to JSON \n   var   user :   User . Profile  }  /// A login error (unsuccessful output)  struct   LoginError :   Encodable ,   ResponseRepresentable   { \n   // The reason will be represented in JSON as a `String` \n   enum   Reason :   String ,   Encodable   { \n     case   invalidCredentials \n     case   accountSuspended \n   } \n\n   var   reason :   Reason  }", 
            "title": "The raw data"
        }, 
        {
            "location": "/getting-started/json/#decoding-the-request", 
            "text": "Request  has a  Body  that will need to be decoded using Foundation's  JSONDecoder .  let   loginRequest   =   try   JSONDecoder (). decode ( LoginRequest . self ,   from :   request . body . data )   The result is a type-safe instantiation of the login request.  { \n   email :   test@example.com , \n   password :   hunter2  }   Decoding the above using the  JSONDecoder  will result in the following  loginRequest .  print ( loginRequest . email )   // prints  test@example.com  print ( loginRequest . password )   // prints  hunter2", 
            "title": "Decoding the Request"
        }, 
        {
            "location": "/getting-started/json/#encoding-an-error-response", 
            "text": "First you need to instantiate your  ResponseRepresentable  response.  Returning this from a  Route  will convert it to a  Response  automatically.  return   LoginError ( reason :   . invalidCredentials )", 
            "title": "Encoding an (error) response"
        }, 
        {
            "location": "/getting-started/cloud/", 
            "text": "TODO", 
            "title": "Deployment"
        }, 
        {
            "location": "/concepts/vapor/", 
            "text": "What is Vapor?\n\n\nVapor is a \nhigh performance\n, type-safe and \neasy to use\n web framework written in and for Swift.\n\n\nVapor is designed for both big and small services, providing a low entry barrier to get started in addition to high performance, well tested and well documented APIs.\n\n\nPerformance\n\n\nVapor's high performance is achieved by a combination of our \nasynchronous architecture\n, Copy on Write mechanics and highly optimized lazy parsers. These three techniques combined with Swift's compiler ensure that our performance is comparable to Go.\n\n\nType safety\n\n\nVapor is designed around type-safety and compile-time checks, ensuring that code doesn't behave in unexpected ways and shows you most problems at compile time. Vapor achieves this by leveraging Swift and it's Codable protocol.\n\n\nWe believe type-safety is critical to both security and developer productivity.\n\n\nEasy to use\n\n\nCreating a new Vapor project takes only a few minutes.\n\n\nWe've got you covered with our thorough documentation and have \nan amazing community\n to back it up!", 
            "title": "What is Vapor?"
        }, 
        {
            "location": "/concepts/vapor/#what-is-vapor", 
            "text": "Vapor is a  high performance , type-safe and  easy to use  web framework written in and for Swift.  Vapor is designed for both big and small services, providing a low entry barrier to get started in addition to high performance, well tested and well documented APIs.", 
            "title": "What is Vapor?"
        }, 
        {
            "location": "/concepts/vapor/#performance", 
            "text": "Vapor's high performance is achieved by a combination of our  asynchronous architecture , Copy on Write mechanics and highly optimized lazy parsers. These three techniques combined with Swift's compiler ensure that our performance is comparable to Go.", 
            "title": "Performance"
        }, 
        {
            "location": "/concepts/vapor/#type-safety", 
            "text": "Vapor is designed around type-safety and compile-time checks, ensuring that code doesn't behave in unexpected ways and shows you most problems at compile time. Vapor achieves this by leveraging Swift and it's Codable protocol.  We believe type-safety is critical to both security and developer productivity.", 
            "title": "Type safety"
        }, 
        {
            "location": "/concepts/vapor/#easy-to-use", 
            "text": "Creating a new Vapor project takes only a few minutes.  We've got you covered with our thorough documentation and have  an amazing community  to back it up!", 
            "title": "Easy to use"
        }, 
        {
            "location": "/concepts/overview/", 
            "text": "Overview\n\n\nVapor is a web framework and ecosystem for developing backends. To get started, this section will cover all concepts surrounding the ecosystem. It is optional, and can be skipped by those who already have experience in web/backend development.\n\n\nHTTP\n\n\nAt the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.\n\n\nThis page\n will cover most of HTTP in depth.\n\n\nAsync and Codable\n\n\nIf you're coming from another language, chances are you've never heard of Swift's Codable protocol. If you don't know what protocols are we can highly recommend reading up on \nthe swift language guide\n. This is a thorough and easy to understand guide through the Swift language. It is not required to read the entire guide before starting, although most concepts mentioned throughout the Vapor documentation will be explained in the guide.\n\n\nAsynchronous programming specifically is an essential part of the Vapor ecosystem that we recommend people \nthat is described here\n.\n\n\nThe same article\n will dive into Codable, a very simple but important protocol in Vapor 3.\n\n\nDatabases\n\n\nLast, but not least, most applications will need a database for managing information such as user accounts, articles and other types of data.\n\n\nChoosing a database can be a complex task for beginners and reading into your database of choice before starting can save a lot of frustration. We aim to simplify this stage \nin this article.\n\n\nFront-end\n\n\nDepending on your application you may need one or more clients to interact with your website. Frontends are very broad. Websites are a frontend that can be designed in various ways. Applications such as iOS and android apps are also considered frontends.\n\n\nTo assist designing your application you can \nread this article.", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/overview/#overview", 
            "text": "Vapor is a web framework and ecosystem for developing backends. To get started, this section will cover all concepts surrounding the ecosystem. It is optional, and can be skipped by those who already have experience in web/backend development.", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/overview/#http", 
            "text": "At the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.  This page  will cover most of HTTP in depth.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/overview/#async-and-codable", 
            "text": "If you're coming from another language, chances are you've never heard of Swift's Codable protocol. If you don't know what protocols are we can highly recommend reading up on  the swift language guide . This is a thorough and easy to understand guide through the Swift language. It is not required to read the entire guide before starting, although most concepts mentioned throughout the Vapor documentation will be explained in the guide.  Asynchronous programming specifically is an essential part of the Vapor ecosystem that we recommend people  that is described here .  The same article  will dive into Codable, a very simple but important protocol in Vapor 3.", 
            "title": "Async and Codable"
        }, 
        {
            "location": "/concepts/overview/#databases", 
            "text": "Last, but not least, most applications will need a database for managing information such as user accounts, articles and other types of data.  Choosing a database can be a complex task for beginners and reading into your database of choice before starting can save a lot of frustration. We aim to simplify this stage  in this article.", 
            "title": "Databases"
        }, 
        {
            "location": "/concepts/overview/#front-end", 
            "text": "Depending on your application you may need one or more clients to interact with your website. Frontends are very broad. Websites are a frontend that can be designed in various ways. Applications such as iOS and android apps are also considered frontends.  To assist designing your application you can  read this article.", 
            "title": "Front-end"
        }, 
        {
            "location": "/concepts/http/", 
            "text": "HTTP\n\n\nAt the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.\n\n\nHTTP comes in two major versions. \nHTTP/1\n and \nHTTP/2\n. Vapor comes with HTTP/1 support by default but has an official package for HTTP/2, too.\n\n\nWhat is the difference?\n\n\nHTTP/1 is a protocol designed in the '90s for the then new and rapidly evolving internet. The protocol is designed around simplicity above security and functionality.\n\n\nHTTP/2 is a protocol with security and performance in mind. Designed with experience of the past 20 years of internet in addition to modern standards such as a high bandwidth and many resources per page.\n\n\nHow it works\n\n\nAt the heart of HTTP lie the \nRequest\n and \nResponse\n. Both of them are \"HTTP Messages\". Both HTTP messages consists of \nHeaders\n and \na body\n.\n\n\nHTTP clients connect to an HTTP server. The clients can send a request to which the server will send a response.\n\n\nBodies contain the concrete information being transferred. Think of the web-page, images, videos, \nJSON\n and \nforms\n.\n\n\nHeaders contain metadata.\n\n\nCookies\n are metadataabout the client that, for example, can be used for identifying users after they've (successfully) logged in. One of these methods are \nsession tokens\n.\n\n\nAnother type of metadata can be related to the content. For example, defining the type of content transferred in the body.\n\n\nRequest\n\n\nRequests have two additional properties in addition to all properties of a Message. The \nMethod\n and \npath\n.\n\n\nThe path is used to specify the resource being accessed. Although there are conventions, there are no rules/limitations to how you structure your paths except their format. Paths consist of \ncomponents\n. The components are separated by a forward slash (\n/\n). All components must be encoded with percent encoding, affecting special characters only.\n\n\nThe \nmethod\n indicated the operation to this resource. \nGET\n is used for reading a resource where \nDELETE\n will (attempt to) remove the resource. This does not mean you need to blindly comply. If a user doesn't have the permissions for said operation, you can emit a response indicating this.\n\n\nResponse\n\n\nResponses have one additional property in addition to the message's properties. This is \nthe status code\n. The status code is used to indicate to the client what the status/result is of a Request. If a client was not authenticated, for example, you would return a status 401 or 403 for \"Unauthorized\" or \"Forbidden\" respectively. \nMore about status codes here.\n\n\nHandling requests\n\n\nRequests in Vapor will be handled by a \nrouter\n. This allows registering a path to a method. For example, registering \n.get(\"users\")\n will register the path \n/users/\n to the method \nGET\n. The responder/closure associated with this route can then handle requests sent to \n/users/\n with the \nGET\n method.\n\n\nTypes of endpoints\n\n\nIn the web we usually define two types of endpoints. Either a website or an API. Websites are HTML pages, usually with associated styling, code and images. APIs are endpoints that communicate with raw information rather than types and user friendly information. APIs are aimed to developers and their applications.\n\n\niOS and Android apps usually communicate with an API, where a web browser such as Safari, Firefox, Chrome or Edge will usually communicate with a website.\n\n\nWebsites\n\n\nWebsites come in two major flavours. Server and client rendered pages. \"Rendering\" in this context doesn't mean the graphical rendering on your monitor, but instead the way information is injected into the HTML DOM to display the information to the users.\n\n\nServer rendered pages make use of a templating system such as \nleaf\n whereas client rendered pages communicate with an API.\n\n\nAPI\n\n\nAPIs are endpoints that sometimes receive but always reply with raw data. The raw data can be in any format. Most commonly, APIs communicate with \nJSON\n. Sometimes, they communicate with XML or other data types. Vapor can flexibly switch between supported formats, both by official or by community made libraries.\n\n\nAPIs in Vapor are (almost) always creating using a \"MVC\" or \"Model View Controller\" model \nwhich we explain here.\n\n\nDesigning an API in Vapor is really simple. \nWe dive into this more here.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/http/#http", 
            "text": "At the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.  HTTP comes in two major versions.  HTTP/1  and  HTTP/2 . Vapor comes with HTTP/1 support by default but has an official package for HTTP/2, too.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/http/#what-is-the-difference", 
            "text": "HTTP/1 is a protocol designed in the '90s for the then new and rapidly evolving internet. The protocol is designed around simplicity above security and functionality.  HTTP/2 is a protocol with security and performance in mind. Designed with experience of the past 20 years of internet in addition to modern standards such as a high bandwidth and many resources per page.", 
            "title": "What is the difference?"
        }, 
        {
            "location": "/concepts/http/#how-it-works", 
            "text": "At the heart of HTTP lie the  Request  and  Response . Both of them are \"HTTP Messages\". Both HTTP messages consists of  Headers  and  a body .  HTTP clients connect to an HTTP server. The clients can send a request to which the server will send a response.  Bodies contain the concrete information being transferred. Think of the web-page, images, videos,  JSON  and  forms .  Headers contain metadata.  Cookies  are metadataabout the client that, for example, can be used for identifying users after they've (successfully) logged in. One of these methods are  session tokens .  Another type of metadata can be related to the content. For example, defining the type of content transferred in the body.", 
            "title": "How it works"
        }, 
        {
            "location": "/concepts/http/#request", 
            "text": "Requests have two additional properties in addition to all properties of a Message. The  Method  and  path .  The path is used to specify the resource being accessed. Although there are conventions, there are no rules/limitations to how you structure your paths except their format. Paths consist of  components . The components are separated by a forward slash ( / ). All components must be encoded with percent encoding, affecting special characters only.  The  method  indicated the operation to this resource.  GET  is used for reading a resource where  DELETE  will (attempt to) remove the resource. This does not mean you need to blindly comply. If a user doesn't have the permissions for said operation, you can emit a response indicating this.", 
            "title": "Request"
        }, 
        {
            "location": "/concepts/http/#response", 
            "text": "Responses have one additional property in addition to the message's properties. This is  the status code . The status code is used to indicate to the client what the status/result is of a Request. If a client was not authenticated, for example, you would return a status 401 or 403 for \"Unauthorized\" or \"Forbidden\" respectively.  More about status codes here.", 
            "title": "Response"
        }, 
        {
            "location": "/concepts/http/#handling-requests", 
            "text": "Requests in Vapor will be handled by a  router . This allows registering a path to a method. For example, registering  .get(\"users\")  will register the path  /users/  to the method  GET . The responder/closure associated with this route can then handle requests sent to  /users/  with the  GET  method.", 
            "title": "Handling requests"
        }, 
        {
            "location": "/concepts/http/#types-of-endpoints", 
            "text": "In the web we usually define two types of endpoints. Either a website or an API. Websites are HTML pages, usually with associated styling, code and images. APIs are endpoints that communicate with raw information rather than types and user friendly information. APIs are aimed to developers and their applications.  iOS and Android apps usually communicate with an API, where a web browser such as Safari, Firefox, Chrome or Edge will usually communicate with a website.", 
            "title": "Types of endpoints"
        }, 
        {
            "location": "/concepts/http/#websites", 
            "text": "Websites come in two major flavours. Server and client rendered pages. \"Rendering\" in this context doesn't mean the graphical rendering on your monitor, but instead the way information is injected into the HTML DOM to display the information to the users.  Server rendered pages make use of a templating system such as  leaf  whereas client rendered pages communicate with an API.", 
            "title": "Websites"
        }, 
        {
            "location": "/concepts/http/#api", 
            "text": "APIs are endpoints that sometimes receive but always reply with raw data. The raw data can be in any format. Most commonly, APIs communicate with  JSON . Sometimes, they communicate with XML or other data types. Vapor can flexibly switch between supported formats, both by official or by community made libraries.  APIs in Vapor are (almost) always creating using a \"MVC\" or \"Model View Controller\" model  which we explain here.  Designing an API in Vapor is really simple.  We dive into this more here.", 
            "title": "API"
        }, 
        {
            "location": "/concepts/async-and-codable/", 
            "text": "This document\n\n\nThis document covers both \nCodable\n and \nAsync\n, the two primary concepts in Vapor 3. Understanding these 2 concepts is essential, even for existing Vapor 1 and 2 users.\n\n\nCodable\n\n\nCodable is any type that's both \nEncodable\n and \nDecodable\n. Encodable types can be serialized to a format, and Decodable types can be deserialized from a format.\n\n\nIf you only want your type to be serializable to another type, then you conform to \nEncodable\n. This will allow serializing this type to other formats such as JSON, XML, MySQL rows, MongoDB/BSON and more. But not backwards.\n\n\nIf you want to be able to construct your type from the raw data, you can conform your type to \nDecodable\n. This will allow converting serialized data to your model (the reverse of \nEncodable\n), allowing JSON, XML, MySQL and MongoDB data to construct your model. This will not allow serialization.\n\n\nIf you want both serialization and deserialization, you can conform to \nCodable\n.\n\n\nFor the best experience you should conform one of the above protocols in the \ndefinition\n of your \nstruct\n or \nclass\n. This way the compiler can infer the protocol requirements automatically. Conforming to these protocols in an extension will require you to manually implement the protocol requirements.\n\n\nstruct\n \nUser\n:\n \nCodable\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n  \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nWith this addition, the above struct can now be (de-)serialized between JSON, XML, MongoDB BSON, MySQL and more!\n\n\nAsync\n\n\nTo understand asynchronous code you must first understand what synchronous code does.\n\n\nSynchronous code is code that writes top to bottom and executes exactly in that order independent of your use case. It does not use callbacks, it does not use futures and it does not use streams. Many information is not immediately available. The internet has a delay between any communication traffic. Querying a database requires sending the query to the database, waiting for the database to process and execute the request, and then receiving the requested information. To keep code synchronous you need to \"block\" the thread. This results in rendering the thread unusable until the response has been received. This is, naturally, inefficient. You're wasting a thread and much performance.\n\n\nThe only clean solution here is to do nonblocking operations. This means that once you send the query, you continue to the next line of code immediately without waiting/blocking. The problem that arises is that the next lines of code are dependent on the result of the previous query's results. For this reason, Vapor 3 introduces \nFutures\n. Futures are very common in many (high performance) ecosystems.", 
            "title": "Async and Codable"
        }, 
        {
            "location": "/concepts/async-and-codable/#this-document", 
            "text": "This document covers both  Codable  and  Async , the two primary concepts in Vapor 3. Understanding these 2 concepts is essential, even for existing Vapor 1 and 2 users.", 
            "title": "This document"
        }, 
        {
            "location": "/concepts/async-and-codable/#codable", 
            "text": "Codable is any type that's both  Encodable  and  Decodable . Encodable types can be serialized to a format, and Decodable types can be deserialized from a format.  If you only want your type to be serializable to another type, then you conform to  Encodable . This will allow serializing this type to other formats such as JSON, XML, MySQL rows, MongoDB/BSON and more. But not backwards.  If you want to be able to construct your type from the raw data, you can conform your type to  Decodable . This will allow converting serialized data to your model (the reverse of  Encodable ), allowing JSON, XML, MySQL and MongoDB data to construct your model. This will not allow serialization.  If you want both serialization and deserialization, you can conform to  Codable .  For the best experience you should conform one of the above protocols in the  definition  of your  struct  or  class . This way the compiler can infer the protocol requirements automatically. Conforming to these protocols in an extension will require you to manually implement the protocol requirements.  struct   User :   Codable   { \n   var   username :   String \n   var   age :   Int  }   With this addition, the above struct can now be (de-)serialized between JSON, XML, MongoDB BSON, MySQL and more!", 
            "title": "Codable"
        }, 
        {
            "location": "/concepts/async-and-codable/#async", 
            "text": "To understand asynchronous code you must first understand what synchronous code does.  Synchronous code is code that writes top to bottom and executes exactly in that order independent of your use case. It does not use callbacks, it does not use futures and it does not use streams. Many information is not immediately available. The internet has a delay between any communication traffic. Querying a database requires sending the query to the database, waiting for the database to process and execute the request, and then receiving the requested information. To keep code synchronous you need to \"block\" the thread. This results in rendering the thread unusable until the response has been received. This is, naturally, inefficient. You're wasting a thread and much performance.  The only clean solution here is to do nonblocking operations. This means that once you send the query, you continue to the next line of code immediately without waiting/blocking. The problem that arises is that the next lines of code are dependent on the result of the previous query's results. For this reason, Vapor 3 introduces  Futures . Futures are very common in many (high performance) ecosystems.", 
            "title": "Async"
        }, 
        {
            "location": "/concepts/controllers/", 
            "text": "TODO", 
            "title": "Controllers"
        }, 
        {
            "location": "/concepts/databases/", 
            "text": "Databases\n\n\nDatabases are an important choice for many applications. They come in many flavours for many different use cases.\n\n\nThis article covers the four most popular databases used by our users.\n\n\nDatabase terminology\n\n\nDatabases\n are a data management system. They allow storing data such as users, articles, relations (such as friends) and any other data structures. Databases allow querying and managing (large) data sets efficiently.\n\n\nQueries\n are a request for (mutation of) information. The most popular query language is SQL, a simple, string based and easily readable query language.\n\n\nNoSQL\n databases are databases which do not query using the SQL syntax. They often also serve a more specific use case.\n\n\nMongoDB\n\n\nMongoDB is the only database in this list that is not an SQL database (or NoSQL). It is designed for extremely large datasets, often with a complex structure. MongoDB supports recursive structures, unlike SQL databases which are one-dimensional.\n\n\nMongoDB's advantages lie in it's architectural difference. It's more easily integrated in data models and more scalable.\n\n\nThe downsides of MongoDB are that the familiar SQL syntax and some table joins are not supported. MongoDB is also a fairly new player, so although it has become very stable and mature it is not as battle tested over the years compared to MySQL.\n\n\nMySQL\n\n\nMySQL is one of the oldest and most robust databases in this list. It's old age has proven the database to be stable and trustworthy. It is an SQL database, meaning it's queries are standardized, widely used, familiar and supported. This makes it extremely attractive to established businesses running SQL.\n\n\nMySQL documentation can be found here.\n\n\n\n\n\nSQLite\n\n\nSQLite is a database that is designed for small applications. It is extremely easy to use in that it only requires a filesystem. It must not be used on cloud services such as \nVapor cloud\n or heroku as those don't persist the SQLite file.\n\n\nSQLite is very limited in it's supported datatypes and should only be used for the most basic applications that should be developed in little time. SQLite databases aren't scalable across multiple servers.\n\n\nUsing SQLite is \ndescribed more thoroughly here.", 
            "title": "Databases"
        }, 
        {
            "location": "/concepts/databases/#databases", 
            "text": "Databases are an important choice for many applications. They come in many flavours for many different use cases.  This article covers the four most popular databases used by our users.", 
            "title": "Databases"
        }, 
        {
            "location": "/concepts/databases/#database-terminology", 
            "text": "Databases  are a data management system. They allow storing data such as users, articles, relations (such as friends) and any other data structures. Databases allow querying and managing (large) data sets efficiently.  Queries  are a request for (mutation of) information. The most popular query language is SQL, a simple, string based and easily readable query language.  NoSQL  databases are databases which do not query using the SQL syntax. They often also serve a more specific use case.", 
            "title": "Database terminology"
        }, 
        {
            "location": "/concepts/databases/#mongodb", 
            "text": "MongoDB is the only database in this list that is not an SQL database (or NoSQL). It is designed for extremely large datasets, often with a complex structure. MongoDB supports recursive structures, unlike SQL databases which are one-dimensional.  MongoDB's advantages lie in it's architectural difference. It's more easily integrated in data models and more scalable.  The downsides of MongoDB are that the familiar SQL syntax and some table joins are not supported. MongoDB is also a fairly new player, so although it has become very stable and mature it is not as battle tested over the years compared to MySQL.", 
            "title": "MongoDB"
        }, 
        {
            "location": "/concepts/databases/#mysql", 
            "text": "MySQL is one of the oldest and most robust databases in this list. It's old age has proven the database to be stable and trustworthy. It is an SQL database, meaning it's queries are standardized, widely used, familiar and supported. This makes it extremely attractive to established businesses running SQL.  MySQL documentation can be found here.", 
            "title": "MySQL"
        }, 
        {
            "location": "/concepts/databases/#sqlite", 
            "text": "SQLite is a database that is designed for small applications. It is extremely easy to use in that it only requires a filesystem. It must not be used on cloud services such as  Vapor cloud  or heroku as those don't persist the SQLite file.  SQLite is very limited in it's supported datatypes and should only be used for the most basic applications that should be developed in little time. SQLite databases aren't scalable across multiple servers.  Using SQLite is  described more thoroughly here.", 
            "title": "SQLite"
        }, 
        {
            "location": "/async/package/", 
            "text": "Using Async\n\n\nAsync is a library revolving around two main concepts:\n\n\n\n\nStreams\n\n\nPromises\n\n\n\n\nTogether they form the foundation of Vapor 3's data flow.\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nAsync\n\n\n\n\n\n\nWithout Vapor\n\n\nAsync is a powerful library for any Swift project. To include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/async.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n1.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nAsync\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Async\n to access Async's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/async/package/#using-async", 
            "text": "Async is a library revolving around two main concepts:   Streams  Promises   Together they form the foundation of Vapor 3's data flow.", 
            "title": "Using Async"
        }, 
        {
            "location": "/async/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Async", 
            "title": "With Vapor"
        }, 
        {
            "location": "/async/package/#without-vapor", 
            "text": "Async is a powerful library for any Swift project. To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/async.git ,   . upToNextMajor ( from :   1.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Async ,   ...   ]) \n     ]  )   Use  import Async  to access Async's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/async/futures-basics/", 
            "text": "Future basics\n\n\nFutures are used throughout Vapor, so it is useful to know some of the available helpers.\n\n\nAdding awaiters to all results\n\n\nIf you need to handle the results of an operation regardless of success or failure, you can do so by calling the \n.addAwaiter\n function on a future.\n\n\nThe awaiter shall be called on completion with a \nResult\nExpectation\n. This is an enum with either the \nExpectation\n or an \nError\n contained within.\n\n\nlet\n \nfuture\n \n=\n \nFuture\n(\nHello world\n)\n\n\n\nfuture\n.\naddAwaiter\n \n{\n \nresult\n \nin\n\n  \nswitch\n \nresult\n \n{\n\n  \ncase\n \n.\nexpectation\n(\nlet\n \nstring\n):\n\n    \nprint\n(\nstring\n)\n\n  \ncase\n \n.\nerror\n(\nlet\n \nerror\n):\n\n    \nprint\n(\nError: \n\\(\nerror\n)\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nFlat-Mapping results\n\n\nNested async callbacks can be a pain to unwind. An example of a painfully complex \"callback hell\" scenario is demonstrated below:\n\n\napp\n.\nget\n(\nfriends\n)\n \n{\n \nrequest\n \nin\n\n    \nlet\n \nsession\n \n=\n \ntry\n \nrequest\n.\ngetSessionCookie\n()\n \nas\n \nUserSession\n\n\n    \nlet\n \npromise\n \n=\n \nPromise\nView\n()\n\n\n    \n// Fetch the user\n\n    \ntry\n \nsession\n.\nuser\n.\nresolve\n().\nthen\n \n{\n \nuser\n \nin\n\n        \n// Returns all the user\ns friends\n\n        \ntry\n \nuser\n.\nfriends\n.\nresolve\n().\nthen\n \n{\n \nfriends\n \nin\n\n            \nreturn\n \ntry\n \nview\n.\nmake\n(\nfriends\n,\n \ncontext\n:\n \nfriends\n,\n \nfor\n:\n \nrequest\n).\nthen\n \n{\n  \nrenderedView\n \nin\n\n                \npromise\n.\ncomplete\n(\nrenderedView\n)\n\n            \n}.\ncatch\n(\npromise\n.\nfail\n)\n\n        \n}.\ncatch\n(\npromise\n.\nfail\n)\n\n    \n}.\ncatch\n(\npromise\n.\nfail\n)\n\n\n    \nreturn\n \npromise\n.\nfuture\n\n\n}\n\n\n\n\n\n\nVapor 3 offers a \nflatMap\n solution here that will help keep the code readable and maintainable.\n\n\napp\n.\nget\n(\nfriends\n)\n \n{\n \nrequest\n \nin\n\n    \nlet\n \nsession\n \n=\n \ntry\n \nrequest\n.\ngetSessionCookie\n()\n \nas\n \nUserSession\n\n\n    \n// Fetch the user\n\n    \nreturn\n \ntry\n \nsession\n.\nuser\n.\nresolve\n().\nflatten\n \n{\n \nuser\n \nin\n\n        \n// Returns all the user\ns friends\n\n        \nreturn\n \ntry\n \nuser\n.\nfriends\n.\nresolve\n()\n\n    \n}.\nmap\n \n{\n \nfriends\n \nin\n\n        \n// Flatten replaced this future with\n\n        \nreturn\n \ntry\n \nview\n.\nmake\n(\nfriends\n,\n \ncontext\n:\n \nfriends\n,\n \nfor\n:\n \nrequest\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nCombining multiple futures\n\n\nIf you're expecting the same type of result from multiple sources you can group them using the \nflatten\n function.\n\n\nvar\n \nfutures\n \n=\n \n[\nFuture\nString\n]()\n\n\nfutures\n.\nappend\n(\nFuture\n(\nHello\n))\n\n\nfutures\n.\nappend\n(\nFuture\n(\nWorld\n))\n\n\nfutures\n.\nappend\n(\nFuture\n(\nFoo\n))\n\n\nfutures\n.\nappend\n(\nFuture\n(\nBar\n))\n\n\n\nlet\n \nfutureResults\n \n=\n \nfutures\n.\nflatten\n()\n \n// Future\n[String]", 
            "title": "Future Basics"
        }, 
        {
            "location": "/async/futures-basics/#future-basics", 
            "text": "Futures are used throughout Vapor, so it is useful to know some of the available helpers.", 
            "title": "Future basics"
        }, 
        {
            "location": "/async/futures-basics/#adding-awaiters-to-all-results", 
            "text": "If you need to handle the results of an operation regardless of success or failure, you can do so by calling the  .addAwaiter  function on a future.  The awaiter shall be called on completion with a  Result Expectation . This is an enum with either the  Expectation  or an  Error  contained within.  let   future   =   Future ( Hello world )  future . addAwaiter   {   result   in \n   switch   result   { \n   case   . expectation ( let   string ): \n     print ( string ) \n   case   . error ( let   error ): \n     print ( Error:  \\( error ) ) \n   }  }", 
            "title": "Adding awaiters to all results"
        }, 
        {
            "location": "/async/futures-basics/#flat-mapping-results", 
            "text": "Nested async callbacks can be a pain to unwind. An example of a painfully complex \"callback hell\" scenario is demonstrated below:  app . get ( friends )   {   request   in \n     let   session   =   try   request . getSessionCookie ()   as   UserSession \n\n     let   promise   =   Promise View () \n\n     // Fetch the user \n     try   session . user . resolve (). then   {   user   in \n         // Returns all the user s friends \n         try   user . friends . resolve (). then   {   friends   in \n             return   try   view . make ( friends ,   context :   friends ,   for :   request ). then   {    renderedView   in \n                 promise . complete ( renderedView ) \n             }. catch ( promise . fail ) \n         }. catch ( promise . fail ) \n     }. catch ( promise . fail ) \n\n     return   promise . future  }   Vapor 3 offers a  flatMap  solution here that will help keep the code readable and maintainable.  app . get ( friends )   {   request   in \n     let   session   =   try   request . getSessionCookie ()   as   UserSession \n\n     // Fetch the user \n     return   try   session . user . resolve (). flatten   {   user   in \n         // Returns all the user s friends \n         return   try   user . friends . resolve () \n     }. map   {   friends   in \n         // Flatten replaced this future with \n         return   try   view . make ( friends ,   context :   friends ,   for :   request ) \n     }  }", 
            "title": "Flat-Mapping results"
        }, 
        {
            "location": "/async/futures-basics/#combining-multiple-futures", 
            "text": "If you're expecting the same type of result from multiple sources you can group them using the  flatten  function.  var   futures   =   [ Future String ]()  futures . append ( Future ( Hello ))  futures . append ( Future ( World ))  futures . append ( Future ( Foo ))  futures . append ( Future ( Bar ))  let   futureResults   =   futures . flatten ()   // Future [String]", 
            "title": "Combining multiple futures"
        }, 
        {
            "location": "/async/streams-introduction/", 
            "text": "Introduction into Streams\n\n\nStreams is a mechanism that you can implement on objects that process any information efficiently and asynchronously without bloat.\n\n\nThere are three primary stream protocols:\n\n\n\n\nInputStream\n\n\nOutputStream\n\n\nStream\n\n\n\n\nConforming to Stream means conformance to both InputStream and OutputStream. So \nStream\n is both processing output and providing output.\n\n\nInputStream is a protocol that, when implemented, accepts streaming input. An example can be a TCP socket that, on input, writes data to the socket.\n\n\nOutputStream is a protocol that, when implement, can emit output.\n\n\nConcept\n\n\nIn Vapor 3 (related libraries), almost everything is a stream. TCP Server is a stream of clients. Each client is a stream of received binary data. For HTTP, each client has an HTTP Request Parser, and Response Serializer. A parser accepts the binary stream and outputs a request stream. And a responder accepts a response and outputs a binary stream (that you can send back to the client's TCP socket as input for the binary stream).\n\n\nDraining streams\n\n\nNow that we've seen how to chain streams, let's talk about draining. In this example the \nTCP Server\n accepts a client stream which can be drained with a closure. This allows additional processing to take place.\n\n\nIn this example we print the string representation of the TCP connnection's incoming data.\n\n\ntcpSocket\n.\ndrain\n \n{\n \nbuffer\n \nin\n\n  \nprint\n(\nString\n(\nbytes\n:\n \nbuffer\n,\n \nencoding\n:\n \n.\nutf8\n))\n\n\n}\n\n\n\n\n\n\nAnother use case for draining is when the stream does not need to be continued any further. After a \nResponse\n has been sent to the Client, nothing else needs to happen.\n\n\nCatching stream errors\n\n\nWhen a (fatal) error occurs, often something need to happen. Many chained streams will do a sensible default. Sockets will close, for example. You can hook into this process by \n.catch\n-ing a stream's errors.\n\n\nstream\n.\ncatch\n \n{\n \nerror\n \nin\n\n  \n// Do something with the error\n\n  \nprint\n(\nerror\n)\n\n\n}\n\n\n\n\n\n\nImplementing an example stream\n\n\nThis example is a stream that deserializes \nByteBuffer\n to \nString\n streaming/asynchronously.\n\n\nstruct\n \nInvalidUTF8\n \n:\n \nError\n \n{}\n\n\n\n// Deserializes `ByteBuffer` (`Input`) to `String` (`Output`) using the provided encoding\n\n\nclass\n \nStringDeserializationStream\n:\n \nAsync\n.\nStream\n \n{\n\n    \ntypealias\n \nInput\n \n=\n \nByteBuffer\n\n    \ntypealias\n \nOutput\n \n=\n \nString\n\n\n    \n// Used only by this specific stream to specify an encoding\n\n    \nlet\n \nencoding\n:\n \nString\n.\nEncoding\n\n\n    \n// \nMARK:\n Stream requirements\n\n\n    \n// An error stream that can be listened to for errors in this stream\n\n    \nvar\n \nerrorStream\n:\n \nBaseStream\n.\nErrorHandler\n?\n\n\n    \n// A handler that can be set to handle output\n\n    \nvar\n \noutputStream\n:\n \nOutputHandler\n?\n\n\n    \n// Creates a new `StringDeserializationStream`\n\n    \ninit\n(\nencoding\n:\n \nString\n.\nEncoding\n \n=\n \n.\nutf8\n)\n \n{\n\n        \n// Sets the String encoding\n\n        \nself\n.\nencoding\n \n=\n \nencoding\n\n    \n}\n\n\n    \n// Receives `Input`/`ByteBuffer` from another stream or manual call\n\n    \n//\n\n    \n// Attempts to process it to a String using the specified encoding\n\n    \nfunc\n \ninputStream\n(\n_\n \ninput\n:\n \nInput\n)\n \n{\n\n        \n// Converts the `Input`/`ByteBuffer` to a String\n\n        \nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \ninput\n,\n \nencoding\n:\n \nself\n.\nencoding\n)\n \n{\n\n            \n// Stream an error if string initialization failed\n\n            \nself\n.\nerrorStream\n?(\nInvalidUTF8\n())\n\n            \nreturn\n\n        \n}\n\n\n        \n// On success, output the created string\n\n        \nself\n.\noutputStream\n?(\nstring\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTransforming streams without an intermediary stream\n\n\nThe above stream \nStringDeserializationStream\n is a very simple example of implementing a stream.\n\n\nStreams support two kinds of transforms. \nflatMap\n and \nmap\n. Map transforms the output of the stream into a new stream with different output. And \nflatMap\n does the same, but allows returning \nnil\n and does not output it.\n\n\n// `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.\n\n\n// `stringStream` is a stream outputting `String`\n\n\nlet\n \nstringStream\n \n=\n \ntcpStream\n.\nflatMap\n \n{\n \nbytes\n \nin\n\n  \nreturn\n \nString\n(\nbytes\n:\n \nbytes\n,\n \nencoding\n:\n \n.\nutf8\n)\n\n\n}\n\n\n\n// `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.\n\n\n// `optionalStringStream` is a stream outputting `String?`\n\n\nlet\n \noptionalStringStream\n \n=\n \ntcpStream\n.\nmap\n \n{\n \nbytes\n \nin\n\n  \nreturn\n \nString\n(\nbytes\n:\n \nbytes\n,\n \nencoding\n:\n \n.\nutf8\n)\n\n\n}\n\n\n\n\n\n\nAs you see, you an provide a closure to do the mapping for you. If you want to reuse this code instead, you could make it a function for simplicity. This function can then be used instead of the closure.\n\n\n// Creates a `String` from `ByteBuffer`. This can return `nil` if the `ByteBuffer` doesn\nt contain valid UTF-8\n\n\nfunc\n \nutf8String\n(\nfrom\n \nbytes\n:\n \nByteBuffer\n)\n \n-\n \nString\n?\n \n{\n\n  \nreturn\n \nString\n(\nbytes\n:\n \nbytes\n,\n \nencoding\n:\n \n.\nutf8\n)\n\n\n}\n\n\n\n// `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.\n\n\n// `stringStream` is a stream outputting `String`\n\n\nlet\n \nstringStream\n \n=\n \ntcpStream\n.\nflatMap\n(\nutf8String\n)\n\n\n\n// `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.\n\n\n// `optionalStringStream` is a stream outputting `String?`\n\n\nlet\n \noptionalStringStream\n \n=\n \ntcpStream\n.\nmap\n(\nutf8String\n)", 
            "title": "Streams Introduction"
        }, 
        {
            "location": "/async/streams-introduction/#introduction-into-streams", 
            "text": "Streams is a mechanism that you can implement on objects that process any information efficiently and asynchronously without bloat.  There are three primary stream protocols:   InputStream  OutputStream  Stream   Conforming to Stream means conformance to both InputStream and OutputStream. So  Stream  is both processing output and providing output.  InputStream is a protocol that, when implemented, accepts streaming input. An example can be a TCP socket that, on input, writes data to the socket.  OutputStream is a protocol that, when implement, can emit output.", 
            "title": "Introduction into Streams"
        }, 
        {
            "location": "/async/streams-introduction/#concept", 
            "text": "In Vapor 3 (related libraries), almost everything is a stream. TCP Server is a stream of clients. Each client is a stream of received binary data. For HTTP, each client has an HTTP Request Parser, and Response Serializer. A parser accepts the binary stream and outputs a request stream. And a responder accepts a response and outputs a binary stream (that you can send back to the client's TCP socket as input for the binary stream).", 
            "title": "Concept"
        }, 
        {
            "location": "/async/streams-introduction/#draining-streams", 
            "text": "Now that we've seen how to chain streams, let's talk about draining. In this example the  TCP Server  accepts a client stream which can be drained with a closure. This allows additional processing to take place.  In this example we print the string representation of the TCP connnection's incoming data.  tcpSocket . drain   {   buffer   in \n   print ( String ( bytes :   buffer ,   encoding :   . utf8 ))  }   Another use case for draining is when the stream does not need to be continued any further. After a  Response  has been sent to the Client, nothing else needs to happen.", 
            "title": "Draining streams"
        }, 
        {
            "location": "/async/streams-introduction/#catching-stream-errors", 
            "text": "When a (fatal) error occurs, often something need to happen. Many chained streams will do a sensible default. Sockets will close, for example. You can hook into this process by  .catch -ing a stream's errors.  stream . catch   {   error   in \n   // Do something with the error \n   print ( error )  }", 
            "title": "Catching stream errors"
        }, 
        {
            "location": "/async/streams-introduction/#implementing-an-example-stream", 
            "text": "This example is a stream that deserializes  ByteBuffer  to  String  streaming/asynchronously.  struct   InvalidUTF8   :   Error   {}  // Deserializes `ByteBuffer` (`Input`) to `String` (`Output`) using the provided encoding  class   StringDeserializationStream :   Async . Stream   { \n     typealias   Input   =   ByteBuffer \n     typealias   Output   =   String \n\n     // Used only by this specific stream to specify an encoding \n     let   encoding :   String . Encoding \n\n     //  MARK:  Stream requirements \n\n     // An error stream that can be listened to for errors in this stream \n     var   errorStream :   BaseStream . ErrorHandler ? \n\n     // A handler that can be set to handle output \n     var   outputStream :   OutputHandler ? \n\n     // Creates a new `StringDeserializationStream` \n     init ( encoding :   String . Encoding   =   . utf8 )   { \n         // Sets the String encoding \n         self . encoding   =   encoding \n     } \n\n     // Receives `Input`/`ByteBuffer` from another stream or manual call \n     // \n     // Attempts to process it to a String using the specified encoding \n     func   inputStream ( _   input :   Input )   { \n         // Converts the `Input`/`ByteBuffer` to a String \n         guard   let   string   =   String ( bytes :   input ,   encoding :   self . encoding )   { \n             // Stream an error if string initialization failed \n             self . errorStream ?( InvalidUTF8 ()) \n             return \n         } \n\n         // On success, output the created string \n         self . outputStream ?( string ) \n     }  }", 
            "title": "Implementing an example stream"
        }, 
        {
            "location": "/async/streams-introduction/#transforming-streams-without-an-intermediary-stream", 
            "text": "The above stream  StringDeserializationStream  is a very simple example of implementing a stream.  Streams support two kinds of transforms.  flatMap  and  map . Map transforms the output of the stream into a new stream with different output. And  flatMap  does the same, but allows returning  nil  and does not output it.  // `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.  // `stringStream` is a stream outputting `String`  let   stringStream   =   tcpStream . flatMap   {   bytes   in \n   return   String ( bytes :   bytes ,   encoding :   . utf8 )  }  // `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.  // `optionalStringStream` is a stream outputting `String?`  let   optionalStringStream   =   tcpStream . map   {   bytes   in \n   return   String ( bytes :   bytes ,   encoding :   . utf8 )  }   As you see, you an provide a closure to do the mapping for you. If you want to reuse this code instead, you could make it a function for simplicity. This function can then be used instead of the closure.  // Creates a `String` from `ByteBuffer`. This can return `nil` if the `ByteBuffer` doesn t contain valid UTF-8  func   utf8String ( from   bytes :   ByteBuffer )   -   String ?   { \n   return   String ( bytes :   bytes ,   encoding :   . utf8 )  }  // `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.  // `stringStream` is a stream outputting `String`  let   stringStream   =   tcpStream . flatMap ( utf8String )  // `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.  // `optionalStringStream` is a stream outputting `String?`  let   optionalStringStream   =   tcpStream . map ( utf8String )", 
            "title": "Transforming streams without an intermediary stream"
        }, 
        {
            "location": "/async/streams-basics/", 
            "text": "Stream Basics\n\n\nStreams are a set of events that occur asynchronously in time. Some events may dispatch immediately, and others may have a delay in nanoseconds, milliseconds, minutes or any other duration. Streams can be linked together to create simple, performant and maintainable software.\n\n\nChaining streams\n\n\nIf an \nOutputStream\n's Output is the same as an \nInputStream\n's input, you can \"chain\" these streams together to create really performant and readable solutions.\n\n\nThis doesn't work for all situation, but let's look at an example that \ndoes\n accept \nbase64\n.\n\n\nclient\n.\nstream\n(\nto\n:\n \nbase64encoder\n).\nstream\n(\nto\n:\n \nclient\n)\n\n\n\n\n\n\nThe result is an \"echo\" server that base64-encodes incoming data, and replies it back in base64-encoded format.\n\n\nAnother good example is how Vapor processes requests internally.\n\n\nlet\n \nserver\n \n=\n \ntry\n \nTCPServer\n(\nport\n:\n \n8080\n,\n \nworker\n:\n \nWorker\n(\nqueue\n:\n \nmyDispatchQueue\n))\n\n\n\n// Servers are a stream of accepted web client connections\n\n\n// Clients are an input and output stream of bytes\n\n\nserver\n.\ndrain\n \n{\n \nclient\n \nin\n\n    \nlet\n \nparser\n \n=\n \nRequestParser\n()\n\n    \nlet\n \nrouter\n \n=\n \ntry\n \nyourApplication\n.\nmake\n(\nRouter\n.\nself\n)\n\n    \nlet\n \nserialiser\n \n=\n \nResponseSerializer\n()\n\n\n    \n// Parses client-sent bytes into the RequestParser\n\n    \nlet\n \nrequestStream\n \n=\n \nclient\n.\nstream\n(\nto\n:\n \nparser\n)\n\n\n    \n// Parses requests to the Vapor router, creating a response\n\n    \nlet\n \nresponseStream\n \n=\n \nrequestStream\n.\nstream\n(\nto\n:\n \nrouter\n)\n\n\n    \n// Serializes the responses, creating a byte stream\n\n    \nlet\n \nserializedResponseStream\n \n=\n \nresponseStream\n.\nstream\n(\nto\n:\n \nserializer\n)\n\n\n    \n// Drains the serialized responses back into the client socket\n\n    \nserializedResponseStream\n.\ndrain\n(\ninto\n:\n \nclient\n)\n\n\n}\n\n\n\n\n\n\nIn the above example, the output of one stream is inputted into another. This ends up taking care of the entire HTTP \nRequest\n/\nResponse\n process.\n\n\nSocket -\n Request-Data -\n Request -\n Processing -\n Response -\n Response-Data -\n Socket", 
            "title": "Stream Basics"
        }, 
        {
            "location": "/async/streams-basics/#stream-basics", 
            "text": "Streams are a set of events that occur asynchronously in time. Some events may dispatch immediately, and others may have a delay in nanoseconds, milliseconds, minutes or any other duration. Streams can be linked together to create simple, performant and maintainable software.", 
            "title": "Stream Basics"
        }, 
        {
            "location": "/async/streams-basics/#chaining-streams", 
            "text": "If an  OutputStream 's Output is the same as an  InputStream 's input, you can \"chain\" these streams together to create really performant and readable solutions.  This doesn't work for all situation, but let's look at an example that  does  accept  base64 .  client . stream ( to :   base64encoder ). stream ( to :   client )   The result is an \"echo\" server that base64-encodes incoming data, and replies it back in base64-encoded format.  Another good example is how Vapor processes requests internally.  let   server   =   try   TCPServer ( port :   8080 ,   worker :   Worker ( queue :   myDispatchQueue ))  // Servers are a stream of accepted web client connections  // Clients are an input and output stream of bytes  server . drain   {   client   in \n     let   parser   =   RequestParser () \n     let   router   =   try   yourApplication . make ( Router . self ) \n     let   serialiser   =   ResponseSerializer () \n\n     // Parses client-sent bytes into the RequestParser \n     let   requestStream   =   client . stream ( to :   parser ) \n\n     // Parses requests to the Vapor router, creating a response \n     let   responseStream   =   requestStream . stream ( to :   router ) \n\n     // Serializes the responses, creating a byte stream \n     let   serializedResponseStream   =   responseStream . stream ( to :   serializer ) \n\n     // Drains the serialized responses back into the client socket \n     serializedResponseStream . drain ( into :   client )  }   In the above example, the output of one stream is inputted into another. This ends up taking care of the entire HTTP  Request / Response  process.  Socket -  Request-Data -  Request -  Processing -  Response -  Response-Data -  Socket", 
            "title": "Chaining streams"
        }, 
        {
            "location": "/async/worker/", 
            "text": "TODO", 
            "title": "Worker"
        }, 
        {
            "location": "/http/", 
            "text": "Using HTTP\n\n\nHTTP is a module as part of the \nEngine\n library containing all HTTP related APIs.\n\n\nIndex\n\n\n\n\nRequest\n\n\nResponse\n\n\nMethod\n\n\nStatus\n\n\nHeaders\n\n\nBody\n\n\nMiddleware\n\n\nMultipart\n\n\nResponder\n\n\nURI\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nHTTP\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/engine.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nHTTP\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport HTTP\n to access HTTP's APIs.", 
            "title": "Index"
        }, 
        {
            "location": "/http/#using-http", 
            "text": "HTTP is a module as part of the  Engine  library containing all HTTP related APIs.", 
            "title": "Using HTTP"
        }, 
        {
            "location": "/http/#index", 
            "text": "Request  Response  Method  Status  Headers  Body  Middleware  Multipart  Responder  URI", 
            "title": "Index"
        }, 
        {
            "location": "/http/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   HTTP", 
            "title": "With Vapor"
        }, 
        {
            "location": "/http/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/engine.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ HTTP ,   ...   ]) \n     ]  )   Use  import HTTP  to access HTTP's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/http/body/", 
            "text": "Body\n\n\nBody contains the bytes transmitted for a \nRequest\n or \nResponse\n. It's contents are related to the \nContent-Type\n header.\n\n\nBody is a binary blob but can contain text like HTML, JSON or another text-based format.\nIt can also contain binary data such as images, ZIP and other files.\n\n\nCreating a Body\n\n\nEmpty bodies can be created using the empty initializer \nBody()\n.\nAlternatively you can provide \nData\n or \nDispatchData\n as the content of the body.\n\n\nBodyRepresentable\n\n\nWhen adding a new struct/class that can be serialized to a Body as part of a Request or Response you can consider implementing the \nBodyRepresentable\n protocol. Below is how String is implemented.\n\n\n/// String can be represented as an HTTP body.\n\n\nextension\n \nString\n:\n \nBodyRepresentable\n \n{\n\n    \n/// See BodyRepresentable.makeBody()\n\n    \npublic\n \nfunc\n \nmakeBody\n()\n \nthrows\n \n-\n \nBody\n \n{\n\n        \nguard\n \nlet\n \ndata\n \n=\n \nself\n.\ndata\n(\nusing\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n            \nthrow\n \nError\n(\nidentifier\n:\n \nstring-body-conversion\n,\n \nreason\n:\n \nConverting a String to an HTTP Body failed.\n)\n\n        \n}\n\n\n        \nreturn\n \nBody\n(\ndata\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe protocol requires the implementation of the \nmakeBody\n function that creates a new \nBody\n.\n\n\nAlthough often unnecessary it is possible to throw an error here if the creation of the body failed.", 
            "title": "Body"
        }, 
        {
            "location": "/http/body/#body", 
            "text": "Body contains the bytes transmitted for a  Request  or  Response . It's contents are related to the  Content-Type  header.  Body is a binary blob but can contain text like HTML, JSON or another text-based format.\nIt can also contain binary data such as images, ZIP and other files.", 
            "title": "Body"
        }, 
        {
            "location": "/http/body/#creating-a-body", 
            "text": "Empty bodies can be created using the empty initializer  Body() .\nAlternatively you can provide  Data  or  DispatchData  as the content of the body.", 
            "title": "Creating a Body"
        }, 
        {
            "location": "/http/body/#bodyrepresentable", 
            "text": "When adding a new struct/class that can be serialized to a Body as part of a Request or Response you can consider implementing the  BodyRepresentable  protocol. Below is how String is implemented.  /// String can be represented as an HTTP body.  extension   String :   BodyRepresentable   { \n     /// See BodyRepresentable.makeBody() \n     public   func   makeBody ()   throws   -   Body   { \n         guard   let   data   =   self . data ( using :   . utf8 )   else   { \n             throw   Error ( identifier :   string-body-conversion ,   reason :   Converting a String to an HTTP Body failed. ) \n         } \n\n         return   Body ( data ) \n     }  }   The protocol requires the implementation of the  makeBody  function that creates a new  Body .  Although often unnecessary it is possible to throw an error here if the creation of the body failed.", 
            "title": "BodyRepresentable"
        }, 
        {
            "location": "/http/client/", 
            "text": "TODO", 
            "title": "Client"
        }, 
        {
            "location": "/http/cookies/", 
            "text": "Cookies\n\n\nCookies are used to store data on the client-side between multiple requests. They're often used for keeping track of a user for various reasons. One of the more important purposes is to store a session cookie containing identification of an account.\n\n\nCreating cookies\n\n\nVapor has three related objects for Cookies.\n\n\nThe \nCookies\n object is an array of multiple Cookie objects.\n\n\nThe \nCookie\n object is a single key-value pair. Where the key is the Cookie name.\n\n\nThe \nValue\n object contains a String representing the Cookie's Value and optional attributes with metadata such as the expiration date of the Cookie.\n\n\nValues\n\n\nValues can be initialized with a String Literal.\n\n\nvar\n \nvalue\n:\n \nCookie\n.\nValue\n \n=\n \nString Literal\n\n\n\n\n\n\nThey can be manipulated to add other properties.\n\n\n// Expires in one day\n\n\nvalue\n.\nexpires\n \n=\n \nDate\n().\naddingTimeInterval\n(\n24\n \n*\n \n3600\n)\n\n\n\n\n\n\nA single Cookie\n\n\nCreating a \nCookie\n requires a name and a Value.\n\n\nlet\n \ncookie\n \n=\n \nCookie\n(\nnamed\n:\n \nsession\n,\n \nvalue\n:\n \nvalue\n)\n\n\n\n\n\n\nMultiple cookies\n\n\nCookies\n can be initialized with a dictionary literal.\n\n\nlet\n \ncookies\n:\n \nCookies\n \n=\n \n[\n\n  \nsession\n:\n \nString Literal\n\n\n]\n\n\n\n\n\n\nThe above will create a single cookie named \"session\" with a value of \"String Literal\".", 
            "title": "Cookies"
        }, 
        {
            "location": "/http/cookies/#cookies", 
            "text": "Cookies are used to store data on the client-side between multiple requests. They're often used for keeping track of a user for various reasons. One of the more important purposes is to store a session cookie containing identification of an account.", 
            "title": "Cookies"
        }, 
        {
            "location": "/http/cookies/#creating-cookies", 
            "text": "Vapor has three related objects for Cookies.  The  Cookies  object is an array of multiple Cookie objects.  The  Cookie  object is a single key-value pair. Where the key is the Cookie name.  The  Value  object contains a String representing the Cookie's Value and optional attributes with metadata such as the expiration date of the Cookie.", 
            "title": "Creating cookies"
        }, 
        {
            "location": "/http/cookies/#values", 
            "text": "Values can be initialized with a String Literal.  var   value :   Cookie . Value   =   String Literal   They can be manipulated to add other properties.  // Expires in one day  value . expires   =   Date (). addingTimeInterval ( 24   *   3600 )", 
            "title": "Values"
        }, 
        {
            "location": "/http/cookies/#a-single-cookie", 
            "text": "Creating a  Cookie  requires a name and a Value.  let   cookie   =   Cookie ( named :   session ,   value :   value )", 
            "title": "A single Cookie"
        }, 
        {
            "location": "/http/cookies/#multiple-cookies", 
            "text": "Cookies  can be initialized with a dictionary literal.  let   cookies :   Cookies   =   [ \n   session :   String Literal  ]   The above will create a single cookie named \"session\" with a value of \"String Literal\".", 
            "title": "Multiple cookies"
        }, 
        {
            "location": "/http/headers/", 
            "text": "Headers\n\n\nHTTP Headers are the metadata of a request/response. They can provide a wide variety of information.\n\n\nHeaders\n are an array of key-value pairs. As such it's possible, but not common for multiple pairs to have the same key.\n\n\nCreating a Headers object\n\n\nThe most common syntax for creating Headers is a dictionary literal.\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\ncontentType\n:\n \ntext/html\n\n\n]\n\n\n\n\n\n\nThe left hand side (key) is a \nHeader.Name\n.\n\n\nA name can also be initialized with a String literal.\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \nContent-Type\n:\n \ntext/html\n\n\n]\n\n\n\n\n\n\nAccessing headers\n\n\nThere are two ways to access Headers. Either by accessing a single (the first) value, or all values.\n\n\nA single value example:\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\ncontentType\n:\n \ntext/html\n\n\n]\n\n\n\nprint\n(\nheaders\n[.\ncontentType\n])\n \n// prints \ntext/html\n\n\n\n\n\n\nAccessing all values example:\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\nsetCookie\n:\n \nsession=afasfwrw3qr241j4qwmdsijfo13k43\n,\n\n  \n.\nsetCookie\n:\n \nawesome=true\n\n\n]\n\n\n\n// prints [\nsession=afasfwrw3qr241j4qwmdsijfo13k43\n, \nawesome=true\n]\n\n\nprint\n(\nheaders\n[\nvaluesFor\n:\n \n.\ncontentType\n])", 
            "title": "Headers"
        }, 
        {
            "location": "/http/headers/#headers", 
            "text": "HTTP Headers are the metadata of a request/response. They can provide a wide variety of information.  Headers  are an array of key-value pairs. As such it's possible, but not common for multiple pairs to have the same key.", 
            "title": "Headers"
        }, 
        {
            "location": "/http/headers/#creating-a-headers-object", 
            "text": "The most common syntax for creating Headers is a dictionary literal.  let   headers :   Headers   =   [ \n   . contentType :   text/html  ]   The left hand side (key) is a  Header.Name .  A name can also be initialized with a String literal.  let   headers :   Headers   =   [ \n   Content-Type :   text/html  ]", 
            "title": "Creating a Headers object"
        }, 
        {
            "location": "/http/headers/#accessing-headers", 
            "text": "There are two ways to access Headers. Either by accessing a single (the first) value, or all values.", 
            "title": "Accessing headers"
        }, 
        {
            "location": "/http/headers/#a-single-value-example", 
            "text": "let   headers :   Headers   =   [ \n   . contentType :   text/html  ]  print ( headers [. contentType ])   // prints  text/html", 
            "title": "A single value example:"
        }, 
        {
            "location": "/http/headers/#accessing-all-values-example", 
            "text": "let   headers :   Headers   =   [ \n   . setCookie :   session=afasfwrw3qr241j4qwmdsijfo13k43 , \n   . setCookie :   awesome=true  ]  // prints [ session=afasfwrw3qr241j4qwmdsijfo13k43 ,  awesome=true ]  print ( headers [ valuesFor :   . contentType ])", 
            "title": "Accessing all values example:"
        }, 
        {
            "location": "/http/method/", 
            "text": "Method\n\n\nMethods are used to indicate the type of operation requested for a route. They're part exclusively in \nHTTP Requests\n and are required.\n\n\n\n\n\n\n\n\nMethod\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n.get\n\n\nUsed for retrieving content\n\n\n\n\n\n\n.head\n\n\nUsed for retrieving content metadata\n\n\n\n\n\n\n.put\n\n\nUsed for replacing content\n\n\n\n\n\n\n.post\n\n\nUsed for creating content\n\n\n\n\n\n\n.delete\n\n\nUsed for deleting content\n\n\n\n\n\n\n\n\nA \npath\n is used for specifying a specific resource/content. The method influences the type of interaction with this resource/content.", 
            "title": "Methods"
        }, 
        {
            "location": "/http/method/#method", 
            "text": "Methods are used to indicate the type of operation requested for a route. They're part exclusively in  HTTP Requests  and are required.     Method  Purpose      .get  Used for retrieving content    .head  Used for retrieving content metadata    .put  Used for replacing content    .post  Used for creating content    .delete  Used for deleting content     A  path  is used for specifying a specific resource/content. The method influences the type of interaction with this resource/content.", 
            "title": "Method"
        }, 
        {
            "location": "/http/middleware/", 
            "text": "Middleware\n\n\nMiddleware are a step in Vapor's responder chain. They're capable of modifying Requests/Responses, preventing the chain from continuing and transforming the data flow.\n\n\nThey can be employed for authorization checks, logging and a wide range of other functionalities.\n\n\nImplementing a Middleware\n\n\nThe following example is a middleware that will prevent all \nrequests\n from going to their respective \nresponder\n unless the origin has a special header set. In the case of a missing header, \nstatus code\n 404 (not found) will be returned.\n\n\nDon't secure your APIs using this example code, it's very unsafe and exclusively to be used as a test.\n\n\npublic\n \nfinal\n \nclass\n \nSpecialHeaderCheckMiddleware\n:\n \nMiddleware\n \n{\n\n  \npublic\n \nfunc\n \nrespond\n(\nto\n \nrequest\n:\n \nRequest\n,\n \nchainingTo\n \nnext\n:\n \nResponder\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nguard\n \nrequest\n.\nheaders\n[\nSecret-Header\n]\n \n==\n \nMagicK3y\n \nelse\n \n{\n\n      \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nnotFound\n)\n\n    \n}\n\n\n    \nreturn\n \ntry\n \nnext\n.\nrespond\n(\nto\n:\n \nrequest\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIntercepting/transforming Responses\n\n\nThe following example demonstrates a middleware that creates a session token for new users.\n\n\n// For the random number\n\n\nimport\n \nCrypto\n\n\n\nstruct\n \nInvalidString\n \n:\n \nSwift\n.\nError\n \n{}\n\n\n\npublic\n \nfinal\n \nclass\n \nSessionTokenMiddleware\n:\n \nMiddleware\n \n{\n\n  \nfunc\n \ngenerateSessionToken\n()\n \nthrows\n \n-\n \nString\n \n{\n\n    \n// Generate token here ...\n\n    \nlet\n \nbase64\n \n=\n \nBase64Encoder\n.\nencode\n(\nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n))\n\n\n    \n// Convert to a String\n\n    \nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nbase64\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n      \n// This can never happen, but throw an error anyways\n\n      \nthrow\n \nInvalidString\n()\n\n    \n}\n\n\n    \nreturn\n \nstring\n\n  \n}\n\n\n  \npublic\n \nfunc\n \nrespond\n(\nto\n \nrequest\n:\n \nRequest\n,\n \nchainingTo\n \nnext\n:\n \nResponder\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nlet\n \nresponse\n \n=\n \ntry\n \nnext\n.\nrespond\n(\nto\n:\n \nrequest\n)\n\n\n    \n// If the session cookie is not set\n\n    \nguard\n \nrequest\n.\ncookies\n[\nsession\n]\n \n!=\n \nnil\n \nelse\n \n{\n\n      \n// Set a new session token\n\n      \nresponse\n.\ncookies\n[\nsession\n]\n \n=\n \ntry\n \ngenerateSessionToken\n()\n\n\n      \nreturn\n \nresponse\n\n    \n}\n\n\n    \nreturn\n \nresponse\n\n  \n}\n\n\n}", 
            "title": "Middleware"
        }, 
        {
            "location": "/http/middleware/#middleware", 
            "text": "Middleware are a step in Vapor's responder chain. They're capable of modifying Requests/Responses, preventing the chain from continuing and transforming the data flow.  They can be employed for authorization checks, logging and a wide range of other functionalities.", 
            "title": "Middleware"
        }, 
        {
            "location": "/http/middleware/#implementing-a-middleware", 
            "text": "The following example is a middleware that will prevent all  requests  from going to their respective  responder  unless the origin has a special header set. In the case of a missing header,  status code  404 (not found) will be returned.  Don't secure your APIs using this example code, it's very unsafe and exclusively to be used as a test.  public   final   class   SpecialHeaderCheckMiddleware :   Middleware   { \n   public   func   respond ( to   request :   Request ,   chainingTo   next :   Responder )   throws   -   Future Response   { \n     guard   request . headers [ Secret-Header ]   ==   MagicK3y   else   { \n       return   Response ( status :   . notFound ) \n     } \n\n     return   try   next . respond ( to :   request ) \n   }  }", 
            "title": "Implementing a Middleware"
        }, 
        {
            "location": "/http/middleware/#interceptingtransforming-responses", 
            "text": "The following example demonstrates a middleware that creates a session token for new users.  // For the random number  import   Crypto  struct   InvalidString   :   Swift . Error   {}  public   final   class   SessionTokenMiddleware :   Middleware   { \n   func   generateSessionToken ()   throws   -   String   { \n     // Generate token here ... \n     let   base64   =   Base64Encoder . encode ( OSRandom (). data ( count :   32 )) \n\n     // Convert to a String \n     guard   let   string   =   String ( bytes :   base64 ,   encoding :   . utf8 )   else   { \n       // This can never happen, but throw an error anyways \n       throw   InvalidString () \n     } \n\n     return   string \n   } \n\n   public   func   respond ( to   request :   Request ,   chainingTo   next :   Responder )   throws   -   Future Response   { \n     let   response   =   try   next . respond ( to :   request ) \n\n     // If the session cookie is not set \n     guard   request . cookies [ session ]   !=   nil   else   { \n       // Set a new session token \n       response . cookies [ session ]   =   try   generateSessionToken () \n\n       return   response \n     } \n\n     return   response \n   }  }", 
            "title": "Intercepting/transforming Responses"
        }, 
        {
            "location": "/http/multipart/", 
            "text": "Multipart Forms\n\n\nMultipart is a module that is primarily used with Forms. Multipart is used for complex forms containing one or more files, input fields and other HTML form data.\n\n\nParsing a multipart form\n\n\nMultipart forms can be parsed using \nMultipartParser\n.\n\n\nlet\n \nmultipartForm\n \n=\n \ntry\n \nMultipartParser\n.\nparse\n(\nfrom\n:\n \nrequest\n)\n\n\n\n\n\n\nReading forms\n\n\nThe parsed form is an array of \nPart\n instances.\nEach of them contains data and headers.\n\n\nYou can read a part using either manually or using the \nForm\n's helpers.\n\n\nlet\n \npictureData\n \n=\n \ntry\n \nmultipartForm\n.\ngetFile\n(\nforName\n:\n \nprofile-picture\n)\n\n\n\n\n\n\nlet\n \nnewPassword\n \n=\n \ntry\n \nmultipartForm\n.\ngetString\n(\nforName\n:\n \npassword\n)", 
            "title": "Multipart"
        }, 
        {
            "location": "/http/multipart/#multipart-forms", 
            "text": "Multipart is a module that is primarily used with Forms. Multipart is used for complex forms containing one or more files, input fields and other HTML form data.", 
            "title": "Multipart Forms"
        }, 
        {
            "location": "/http/multipart/#parsing-a-multipart-form", 
            "text": "Multipart forms can be parsed using  MultipartParser .  let   multipartForm   =   try   MultipartParser . parse ( from :   request )", 
            "title": "Parsing a multipart form"
        }, 
        {
            "location": "/http/multipart/#reading-forms", 
            "text": "The parsed form is an array of  Part  instances.\nEach of them contains data and headers.  You can read a part using either manually or using the  Form 's helpers.  let   pictureData   =   try   multipartForm . getFile ( forName :   profile-picture )   let   newPassword   =   try   multipartForm . getString ( forName :   password )", 
            "title": "Reading forms"
        }, 
        {
            "location": "/http/request/", 
            "text": "Request\n\n\nWhen a client connects with an HTTP Server it sends a \nRequest\n. This HTTP request will be processed \nas discussed here\n and resolved into a \nResponse\n. This is the response in the http \nRequest/Response model\n.\n\n\nRequests consist of a \nMethod\n, \nURI\n and \nHeaders\n.\n\n\nRequests can optionally also contain a \nBody\n.\n\n\nRequests are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nRequest properties\n\n\nRequest has a few primary properties according to spec, and one extra property as part of the Vapor framework.\n\n\nThe \nRequest Method\n, \nURI\n, \nHeaders\n and \nBody\n are available.\n\n\nWe also provide access to the HTTP version, although this will almost always be \n1.1\n.\n\n\nIn addition to these properties there is an Extend available which an be used to store extra information for each request.\n\n\nIt can be used to store information between \nmiddlewares\n and the responder and is used by Vapor to store the current \nWorker\n, too.\n\n\nUsing Extend, many properties can be added in extensions.\n\n\nCreating a Request\n\n\nCreating requests is necessary for \nHTTP Clients\n.\n\n\nA request accepts a method, uri, version, headers and body. The version's default is recommended. The body is optional.\n\n\nThe body can be a \nBody\n or \nBodyRepresentable\n. If the body is a \nBodyRepresentable\n the \nResponse\n initializer will become throwing.\n\n\nlet\n \nrequest1\n \n=\n \nRequest\n(\n\n                \nmethod\n:\n \n.\nget\n,\n\n                \nuri\n:\n \nuri\n,\n\n                \nheaders\n:\n \nheaders\n,\n\n                \nbody\n:\n \nbody\n\n              \n)\n\n\n\nlet\n \nrequest2\n \n=\n \ntry\n \nRequest\n(\n\n                \nmethod\n:\n \n.\nget\n,\n\n                \nuri\n:\n \nuri\n,\n\n                \nheaders\n:\n \nheaders\n,\n\n                \nbody\n:\n \nbodyRepresentable\n\n              \n)", 
            "title": "Request"
        }, 
        {
            "location": "/http/request/#request", 
            "text": "When a client connects with an HTTP Server it sends a  Request . This HTTP request will be processed  as discussed here  and resolved into a  Response . This is the response in the http  Request/Response model .  Requests consist of a  Method ,  URI  and  Headers .  Requests can optionally also contain a  Body .  Requests are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.", 
            "title": "Request"
        }, 
        {
            "location": "/http/request/#request-properties", 
            "text": "Request has a few primary properties according to spec, and one extra property as part of the Vapor framework.  The  Request Method ,  URI ,  Headers  and  Body  are available.  We also provide access to the HTTP version, although this will almost always be  1.1 .  In addition to these properties there is an Extend available which an be used to store extra information for each request.  It can be used to store information between  middlewares  and the responder and is used by Vapor to store the current  Worker , too.  Using Extend, many properties can be added in extensions.", 
            "title": "Request properties"
        }, 
        {
            "location": "/http/request/#creating-a-request", 
            "text": "Creating requests is necessary for  HTTP Clients .  A request accepts a method, uri, version, headers and body. The version's default is recommended. The body is optional.  The body can be a  Body  or  BodyRepresentable . If the body is a  BodyRepresentable  the  Response  initializer will become throwing.  let   request1   =   Request ( \n                 method :   . get , \n                 uri :   uri , \n                 headers :   headers , \n                 body :   body \n               )  let   request2   =   try   Request ( \n                 method :   . get , \n                 uri :   uri , \n                 headers :   headers , \n                 body :   bodyRepresentable \n               )", 
            "title": "Creating a Request"
        }, 
        {
            "location": "/http/response/", 
            "text": "HTTP Response\n\n\nWhen a client connects with an HTTP Server it sends a \nRequest\n. This HTTP request will be processed \nas discussed here\n and resolved into a \nResponse\n. This is the response in the http Request/Response model.\n\n\nHTTP's Response object contains a \nStatus\n, \nHeaders\n and a \nBody\n. Before further reading this page, you must have read and understood the previous pages for Status, Headers and Body.\n\n\nResponses are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nCreating a Response\n\n\nA Response accepts a version, status, headers and body. The version's default is recommended. The body is optional.\n\n\nThe body can be a \nBody\n or \nBodyRepresentable\n. If the body is a \nBodyRepresentable\n the \nResponse\n initializer will become throwing.\n\n\nlet\n \nresponse1\n \n=\n \nResponse\n(\n\n                  \nstatus\n:\n \nstatus\n,\n\n                  \nheaders\n:\n \nheaders\n,\n\n                  \nbody\n:\n \nbody\n)\n\n\n\nlet\n \nresponse2\n \n=\n \ntry\n \nResponse\n(\n\n                  \nstatus\n:\n \nstatus\n,\n\n                  \nheaders\n:\n \nheaders\n,\n\n                  \nbody\n:\n \nbodyRepresentable\n)\n\n\n\n\n\n\nResponseRepresentable\n\n\nInstead of requiring a Response, many parts of the framework and related libraries work with the protocol \nResponseRepresentable\n. When types conform to \nResponseRepresentable\n they're required to implement a \nmakeResponse\n function that allows conversion from this instance to a \nResponse\n.\n\n\nFor the purpose of an example, we'll convert an integer to a \nResponse\n. This \nInt\n will always response with a status code 200 (OK) and a body containing itself in textual representation.\n\n\nextension\n \nInt\n:\n \nResponseRepresentable\n \n{\n\n  \npublic\n \nfunc\n \nmakeResponse\n()\n \nthrows\n \n-\n \nResponse\n \n{\n\n    \nreturn\n \ntry\n \nResponse\n(\nstatus\n:\n \n.\nok\n,\n \nbody\n:\n \nself\n.\ndescription\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nResponseInitializable\n\n\nResponseInitializable\n is used for converting a \nResponse\n to another type.\n\n\nThis is particularly useful for \nHTTP Clients\n that interact with existing APIs.\n\n\nThis example is pseudocode for interacting with a payment API such as Stripe or PayPal in a type-safe fashion.\n\n\nstruct\n \nPaymentStatus\n:\n \nResponseInitializable\n \n{\n\n  \npublic\n \ninit\n(\nresponse\n:\n \nResponse\n)\n \nthrows\n \n{\n\n    \n// Create a `PaymentStatus` from the API call\ns `Response`\n\n  \n}\n\n\n}", 
            "title": "Response"
        }, 
        {
            "location": "/http/response/#http-response", 
            "text": "When a client connects with an HTTP Server it sends a  Request . This HTTP request will be processed  as discussed here  and resolved into a  Response . This is the response in the http Request/Response model.  HTTP's Response object contains a  Status ,  Headers  and a  Body . Before further reading this page, you must have read and understood the previous pages for Status, Headers and Body.  Responses are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.", 
            "title": "HTTP Response"
        }, 
        {
            "location": "/http/response/#creating-a-response", 
            "text": "A Response accepts a version, status, headers and body. The version's default is recommended. The body is optional.  The body can be a  Body  or  BodyRepresentable . If the body is a  BodyRepresentable  the  Response  initializer will become throwing.  let   response1   =   Response ( \n                   status :   status , \n                   headers :   headers , \n                   body :   body )  let   response2   =   try   Response ( \n                   status :   status , \n                   headers :   headers , \n                   body :   bodyRepresentable )", 
            "title": "Creating a Response"
        }, 
        {
            "location": "/http/response/#responserepresentable", 
            "text": "Instead of requiring a Response, many parts of the framework and related libraries work with the protocol  ResponseRepresentable . When types conform to  ResponseRepresentable  they're required to implement a  makeResponse  function that allows conversion from this instance to a  Response .  For the purpose of an example, we'll convert an integer to a  Response . This  Int  will always response with a status code 200 (OK) and a body containing itself in textual representation.  extension   Int :   ResponseRepresentable   { \n   public   func   makeResponse ()   throws   -   Response   { \n     return   try   Response ( status :   . ok ,   body :   self . description ) \n   }  }", 
            "title": "ResponseRepresentable"
        }, 
        {
            "location": "/http/response/#responseinitializable", 
            "text": "ResponseInitializable  is used for converting a  Response  to another type.  This is particularly useful for  HTTP Clients  that interact with existing APIs.  This example is pseudocode for interacting with a payment API such as Stripe or PayPal in a type-safe fashion.  struct   PaymentStatus :   ResponseInitializable   { \n   public   init ( response :   Response )   throws   { \n     // Create a `PaymentStatus` from the API call s `Response` \n   }  }", 
            "title": "ResponseInitializable"
        }, 
        {
            "location": "/http/responder/", 
            "text": "Responder\n\n\nResponders are a type capable of \nresponding\n to a \nRequest\n.\n\n\nResponders are always \nasync\n by returning a \nFuture\nResponse\n by either transforming/mapping an existing future or creating it's own promise.\n\n\nImplementing a static Responder\n\n\nstruct\n \nStaticResponder\n:\n \nResponder\n \n{\n\n  \nlet\n \nresponse\n:\n \nResponse\n\n\n  \ninit\n(\nresponse\n:\n \nResponse\n)\n \n{\n\n    \nself\n.\nresponse\n \n=\n \nresponse\n\n  \n}\n\n\n  \nfunc\n \nrespond\n(\nto\n \nreq\n:\n \nRequest\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nreturn\n \nFuture\n(\nresponse\n)\n\n  \n}\n\n\n}", 
            "title": "Responder"
        }, 
        {
            "location": "/http/responder/#responder", 
            "text": "Responders are a type capable of  responding  to a  Request .  Responders are always  async  by returning a  Future Response  by either transforming/mapping an existing future or creating it's own promise.", 
            "title": "Responder"
        }, 
        {
            "location": "/http/responder/#implementing-a-static-responder", 
            "text": "struct   StaticResponder :   Responder   { \n   let   response :   Response \n\n   init ( response :   Response )   { \n     self . response   =   response \n   } \n\n   func   respond ( to   req :   Request )   throws   -   Future Response   { \n     return   Future ( response ) \n   }  }", 
            "title": "Implementing a static Responder"
        }, 
        {
            "location": "/http/status/", 
            "text": "Status codes\n\n\nStatus codes are exclusively part of the \nHTTP Response\n and are required.\n\n\nStatus codes are a 3 digit number.\n\n\nThe first of the 3 numbers indicated the type of response.\n\n\n\n\n\n\n\n\n_xx\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n1xx\n\n\nInformational response\n\n\n\n\n\n\n2xx\n\n\nSuccess\n\n\n\n\n\n\n3xx\n\n\nRedirection\n\n\n\n\n\n\n4xx\n\n\nClient error\n\n\n\n\n\n\n5xx\n\n\nServer error\n\n\n\n\n\n\n\n\nThe other 2 numbers in a status code are used to define a specific code.\n\n\nSelecting a status code\n\n\nThe enum \nStatus\n has all supported status codes. It can be accessed using a \n.\n or created using an integer literal.\n\n\nlet\n \nok\n \n=\n \nStatus\n.\nok\n\n\nlet\n \nnotFound\n \n=\n \nStatus\n.\nnotFound\n\n\n\n\n\n\nlet\n \nok\n:\n \nStatus\n \n=\n \n200\n\n\nlet\n \nnotFound\n:\n \nStatus\n \n=\n \n404\n\n\n\n\n\n\nInformational responses\n\n\nInformational responses indicate a \nRequest\n was received and understood.\n\n\n101 - switching protocols\n\n\nSwitching Protocols is a status code used to upgrade the connection to a different protocol. Commonly used by \nWebSocket\n or HTTP/2.\n\n\nSuccess responses\n\n\nSuccess responses indicate that the request was received, understood, accepted and processed.\n\n\n200 - OK\n\n\n200, or \"OK\" is the most common status code. It's used to indicate successful processing of the Request.\n\n\nRedirection responses\n\n\nRedirection responses indicate the client must take additional action to complete the request. Many of these status codes are used in URL redirection.\n\n\nClient error responses\n\n\nClient errors indicate an error was caused by the client.\n\n\n400 - Bad Request\n\n\nThe error was caused by the client sending an invalid request.\n\n\nFor example an invalid message, malformed request syntax or too large request size.\n\n\n403 - Forbidden\n\n\nThe client does not have the permissions to execute this operation on the specified resource.\n\n\n404 - Not found\n\n\nThe requested resource does not exist.\n\n\nServer error responses\n\n\nServer errors occur when the an error occurred on the server side.\n\n\n500 - Internal Server Error\n\n\nInternal server errors are almost exclusively used when an error occurred on the server.", 
            "title": "Status codes"
        }, 
        {
            "location": "/http/status/#status-codes", 
            "text": "Status codes are exclusively part of the  HTTP Response  and are required.  Status codes are a 3 digit number.  The first of the 3 numbers indicated the type of response.     _xx  Meaning      1xx  Informational response    2xx  Success    3xx  Redirection    4xx  Client error    5xx  Server error     The other 2 numbers in a status code are used to define a specific code.", 
            "title": "Status codes"
        }, 
        {
            "location": "/http/status/#selecting-a-status-code", 
            "text": "The enum  Status  has all supported status codes. It can be accessed using a  .  or created using an integer literal.  let   ok   =   Status . ok  let   notFound   =   Status . notFound   let   ok :   Status   =   200  let   notFound :   Status   =   404", 
            "title": "Selecting a status code"
        }, 
        {
            "location": "/http/status/#informational-responses", 
            "text": "Informational responses indicate a  Request  was received and understood.", 
            "title": "Informational responses"
        }, 
        {
            "location": "/http/status/#101-switching-protocols", 
            "text": "Switching Protocols is a status code used to upgrade the connection to a different protocol. Commonly used by  WebSocket  or HTTP/2.", 
            "title": "101 - switching protocols"
        }, 
        {
            "location": "/http/status/#success-responses", 
            "text": "Success responses indicate that the request was received, understood, accepted and processed.", 
            "title": "Success responses"
        }, 
        {
            "location": "/http/status/#200-ok", 
            "text": "200, or \"OK\" is the most common status code. It's used to indicate successful processing of the Request.", 
            "title": "200 - OK"
        }, 
        {
            "location": "/http/status/#redirection-responses", 
            "text": "Redirection responses indicate the client must take additional action to complete the request. Many of these status codes are used in URL redirection.", 
            "title": "Redirection responses"
        }, 
        {
            "location": "/http/status/#client-error-responses", 
            "text": "Client errors indicate an error was caused by the client.", 
            "title": "Client error responses"
        }, 
        {
            "location": "/http/status/#400-bad-request", 
            "text": "The error was caused by the client sending an invalid request.  For example an invalid message, malformed request syntax or too large request size.", 
            "title": "400 - Bad Request"
        }, 
        {
            "location": "/http/status/#403-forbidden", 
            "text": "The client does not have the permissions to execute this operation on the specified resource.", 
            "title": "403 - Forbidden"
        }, 
        {
            "location": "/http/status/#404-not-found", 
            "text": "The requested resource does not exist.", 
            "title": "404 - Not found"
        }, 
        {
            "location": "/http/status/#server-error-responses", 
            "text": "Server errors occur when the an error occurred on the server side.", 
            "title": "Server error responses"
        }, 
        {
            "location": "/http/status/#500-internal-server-error", 
            "text": "Internal server errors are almost exclusively used when an error occurred on the server.", 
            "title": "500 - Internal Server Error"
        }, 
        {
            "location": "/http/uri/", 
            "text": "URI\n\n\nURIs or \"Uniform Resource Identifiers\" are used for defining a resource.\n\n\nThey consist of the following components:\n\n\n\n\nscheme\n\n\nauthority\n\n\npath\n\n\nquery\n\n\nfragment\n\n\n\n\nCreating an URI\n\n\nURIs can be created from it's initializer or from a String literal.\n\n\nlet\n \nstringLiteralURI\n:\n \nURI\n \n=\n \nhttp://localhost:8080/path\n\n\nlet\n \nmanualURI\n:\n \nURI\n \n=\n \nURI\n(\n\n    \nscheme\n:\n \nhttp\n,\n\n    \nhostname\n:\n \nlocalhost\n,\n\n    \nport\n:\n \n8080\n,\n\n    \npath\n:\n \n/path\n\n\n)", 
            "title": "URI"
        }, 
        {
            "location": "/http/uri/#uri", 
            "text": "URIs or \"Uniform Resource Identifiers\" are used for defining a resource.  They consist of the following components:   scheme  authority  path  query  fragment", 
            "title": "URI"
        }, 
        {
            "location": "/http/uri/#creating-an-uri", 
            "text": "URIs can be created from it's initializer or from a String literal.  let   stringLiteralURI :   URI   =   http://localhost:8080/path  let   manualURI :   URI   =   URI ( \n     scheme :   http , \n     hostname :   localhost , \n     port :   8080 , \n     path :   /path  )", 
            "title": "Creating an URI"
        }, 
        {
            "location": "/fluent/getting-started/package/", 
            "text": "Adding Fluent to your Project\n\n\nFluent (\nvapor/fluent\n) is a type-safe, fast, and easy-to-use ORM built for Swift. \nIt takes advantage of Swift's strong type system to provide an elegant API for your database.\n\n\nDatabase\n\n\nIn addition to adding Fluent to your project, you must also add a Fluent compatible database. \nFluent does not include any databases by default. All official databases have a getting started guide similar to this one. \n\n\n\n\n\n\n\n\ndatabase\n\n\nlibrary\n\n\ndriver\n\n\nguide\n\n\n\n\n\n\n\n\n\n\nPostgreSQL\n\n\nvapor/postgres\n\n\nvapor/fluent-postgres\n\n\nPostgreSQL \n Package\n\n\n\n\n\n\nMySQL\n\n\nvapor/mysql\n\n\nvapor/fluent-mysql\n\n\nMySQL \n Package\n\n\n\n\n\n\nSQLite\n\n\nvapor/sqlite\n\n\nvapor/fluent-sqlite\n\n\nSQLite \n Package\n\n\n\n\n\n\nMongoDB\n\n\nmongokitten/mongokitten\n\n\nvapor/fluent-mongokitten\n\n\nREADME.md\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nAny database can be made to work with Fluent by conforming to its \nDatabase\n protocol. \nFor a list of all compatible database types, search GitHub for the \nfluent-driver\n topic.\n\n\n\n\nFluent\n\n\nAfter you have added your database driver, simply add the Fluent package to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/fluent.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nFluent\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\n\n\nNote\n\n\nUse \nimport Fluent\n to access Fluent's APIs.\n\n\n\n\nOnce you have Fluent added to your project, you are ready to \nconfigure your database(s)\n.", 
            "title": "Package"
        }, 
        {
            "location": "/fluent/getting-started/package/#adding-fluent-to-your-project", 
            "text": "Fluent ( vapor/fluent ) is a type-safe, fast, and easy-to-use ORM built for Swift. \nIt takes advantage of Swift's strong type system to provide an elegant API for your database.", 
            "title": "Adding Fluent to your Project"
        }, 
        {
            "location": "/fluent/getting-started/package/#database", 
            "text": "In addition to adding Fluent to your project, you must also add a Fluent compatible database. \nFluent does not include any databases by default. All official databases have a getting started guide similar to this one.      database  library  driver  guide      PostgreSQL  vapor/postgres  vapor/fluent-postgres  PostgreSQL   Package    MySQL  vapor/mysql  vapor/fluent-mysql  MySQL   Package    SQLite  vapor/sqlite  vapor/fluent-sqlite  SQLite   Package    MongoDB  mongokitten/mongokitten  vapor/fluent-mongokitten  README.md      Tip  Any database can be made to work with Fluent by conforming to its  Database  protocol. \nFor a list of all compatible database types, search GitHub for the  fluent-driver  topic.", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/getting-started/package/#fluent", 
            "text": "After you have added your database driver, simply add the Fluent package to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/fluent.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Fluent ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .   Note  Use  import Fluent  to access Fluent's APIs.   Once you have Fluent added to your project, you are ready to  configure your database(s) .", 
            "title": "Fluent"
        }, 
        {
            "location": "/fluent/getting-started/provider/", 
            "text": "Configuring Fluent\n\n\nFluent integrates seamlessly into your Vapor project using \nservices\n. \nIn this section we will add the Fluent service provider to your application and configure your databases.\n\n\n\n\nWarning\n\n\nThis section assumes you have added both \nFluent\n and a \nFluent database\n to your package.\n\n\n\n\nService Provider\n\n\nThe first step to using Fluent, is registering it with your Vapor application.\n\n\nimport\n \nFluent\n\n\n\n...\n\n\n\ntry\n \nservices\n.\nregister\n(\nFluentProvider\n())\n\n\n\n\n\n\nRegister the \nFluentProvider\n in the \nconfigure section\n of your application. \n\n\n\n\nQuestion\n\n\nLearn more about how service providers work in \nGetting Started: Application\n\nand \nConcepts: Services\n.\n\n\n\n\nConfig\n\n\nOnce the service provider has been added, we can configure one or more databases \nto be used with Fluent.\n\n\nIdentifier\n\n\nEach database you use with Fluent must have a unique identifier. The easiest way to \nkeep track of this identifier is to add it as static extension to \nDatabaseIdentifier\n.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFluentSQLite\n\n\n\nextension\n \nDatabaseIdentifier\n \n{\n\n    \nstatic\n \nvar\n \nfoo\n:\n \nDatabaseIdentifier\nSQLiteDatabase\n \n{\n\n        \nreturn\n \n.\ninit\n(\nfoo\n)\n\n    \n}\n\n\n    \nstatic\n \nvar\n \nbar\n:\n \nDatabaseIdentifier\nMySQLDatabase\n \n{\n\n        \nreturn\n \n.\ninit\n(\nbar\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow we can use the identifier anywhere in our project:\n\n\nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\nThe \nconfigure section\n of your project is a good place to put this extension.\n\n\nDatabases\n\n\nNow that we have created a unique identifier for our database, we can register it\nto our application using \nDatabaseConfig\n. A good place to do this is in the\n\nconfigure section\n of your project.\n\n\nYou can add databases to the \nDatabaseConfig\n using either a type (\n.self\n) or an instance.\n\n\nType\n\n\nIf you register a database type (like \nSQLiteDatabase.self\n), Fluent will ask the application\nto create an instance of your database at boot.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentSQLite\n\n\n\n...\n\n\n\nvar\n \ndatabaseConfig\n \n=\n \nDatabaseConfig\n()\n\n\n\ndatabaseConfig\n.\nadd\n(\ndatabase\n:\n \nSQLiteDatabase\n.\nself\n,\n \nas\n:\n \n.\nfoo\n)\n\n\n\nservices\n.\nregister\n(\ndatabaseConfig\n)\n\n\n\n\n\n\nInstance\n\n\nYou can also register a pre-initialized database. This is especially useful if you'd \nlike to configure two instances of the same database type.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentMySQL\n\n\n\n...\n\n\n\nvar\n \ndatabaseConfig\n \n=\n \nDatabaseConfig\n()\n\n\n\nlet\n \nmysql\n \n=\n \nMySQLDatabase\n(...)\n\n\ndatabaseConfig\n.\nadd\n(\ndatabase\n:\n \nmysql\n,\n \nas\n:\n \n.\nbar\n)\n\n\n\nservices\n.\nregister\n(\ndatabaseConfig\n)\n\n\n\n\n\n\nMigrations\n\n\nIf your database uses schemas (most SQL databases do, whereas NoSQL databases don't), you will also want to configure\nyour migrations using \nMigrationConfig\n.\n\n\nimport\n \nFluent\n\n\n\n...\n\n\n\nvar\n \nmigrationConfig\n \n=\n \nMigrationConfig\n()\n\n\n\nmigrationConfig\n.\nadd\n(\nmigration\n:\n \nUser\n.\nself\n,\n \ndatabase\n:\n \n.\nfoo\n)\n\n\n\nservices\n.\nregister\n(\nmigrationConfig\n)\n\n\n\n\n\n\nYou can read more about migrations in \nFluent: Migrations\n.\n\n\nDone\n\n\nYou should now be able to compile and run your application. The next step is to create your\nmodels.", 
            "title": "Provider"
        }, 
        {
            "location": "/fluent/getting-started/provider/#configuring-fluent", 
            "text": "Fluent integrates seamlessly into your Vapor project using  services . \nIn this section we will add the Fluent service provider to your application and configure your databases.   Warning  This section assumes you have added both  Fluent  and a  Fluent database  to your package.", 
            "title": "Configuring Fluent"
        }, 
        {
            "location": "/fluent/getting-started/provider/#service-provider", 
            "text": "The first step to using Fluent, is registering it with your Vapor application.  import   Fluent  ...  try   services . register ( FluentProvider ())   Register the  FluentProvider  in the  configure section  of your application.    Question  Learn more about how service providers work in  Getting Started: Application \nand  Concepts: Services .", 
            "title": "Service Provider"
        }, 
        {
            "location": "/fluent/getting-started/provider/#config", 
            "text": "Once the service provider has been added, we can configure one or more databases \nto be used with Fluent.", 
            "title": "Config"
        }, 
        {
            "location": "/fluent/getting-started/provider/#identifier", 
            "text": "Each database you use with Fluent must have a unique identifier. The easiest way to \nkeep track of this identifier is to add it as static extension to  DatabaseIdentifier .  import   Fluent  import   FluentMySQL  import   FluentSQLite  extension   DatabaseIdentifier   { \n     static   var   foo :   DatabaseIdentifier SQLiteDatabase   { \n         return   . init ( foo ) \n     } \n\n     static   var   bar :   DatabaseIdentifier MySQLDatabase   { \n         return   . init ( bar ) \n     }  }   Now we can use the identifier anywhere in our project:  req . database (. foo )   {   ...   }   The  configure section  of your project is a good place to put this extension.", 
            "title": "Identifier"
        }, 
        {
            "location": "/fluent/getting-started/provider/#databases", 
            "text": "Now that we have created a unique identifier for our database, we can register it\nto our application using  DatabaseConfig . A good place to do this is in the configure section  of your project.  You can add databases to the  DatabaseConfig  using either a type ( .self ) or an instance.", 
            "title": "Databases"
        }, 
        {
            "location": "/fluent/getting-started/provider/#type", 
            "text": "If you register a database type (like  SQLiteDatabase.self ), Fluent will ask the application\nto create an instance of your database at boot.  import   Fluent  import   FluentSQLite  ...  var   databaseConfig   =   DatabaseConfig ()  databaseConfig . add ( database :   SQLiteDatabase . self ,   as :   . foo )  services . register ( databaseConfig )", 
            "title": "Type"
        }, 
        {
            "location": "/fluent/getting-started/provider/#instance", 
            "text": "You can also register a pre-initialized database. This is especially useful if you'd \nlike to configure two instances of the same database type.  import   Fluent  import   FluentMySQL  ...  var   databaseConfig   =   DatabaseConfig ()  let   mysql   =   MySQLDatabase (...)  databaseConfig . add ( database :   mysql ,   as :   . bar )  services . register ( databaseConfig )", 
            "title": "Instance"
        }, 
        {
            "location": "/fluent/getting-started/provider/#migrations", 
            "text": "If your database uses schemas (most SQL databases do, whereas NoSQL databases don't), you will also want to configure\nyour migrations using  MigrationConfig .  import   Fluent  ...  var   migrationConfig   =   MigrationConfig ()  migrationConfig . add ( migration :   User . self ,   database :   . foo )  services . register ( migrationConfig )   You can read more about migrations in  Fluent: Migrations .", 
            "title": "Migrations"
        }, 
        {
            "location": "/fluent/getting-started/provider/#done", 
            "text": "You should now be able to compile and run your application. The next step is to create your\nmodels.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/getting-started/models/", 
            "text": "Getting Started with Models\n\n\nModels are the heart of Fluent. Unlike ORMs in other languages, Fluent doesn't return untyped \narrays or dictionaries for queries. Instead, you query the database using models. This allows the \nSwift compiler to catch many errors that have burdened ORM users for ages.\n\n\nIn this guide, we will cover the creation of a basic \nUser\n model. See \nFluent \n Model\n for\nmore in-depth information about the model protocol.\n\n\nClass\n\n\nEvery Fluent model starts with a \nCodable\n class. You can make any \nCodable\n class a Fluent model, \neven ones that come from a different module. All you have to do is conform to \nModel\n. \n\n\nimport\n \nFoundation\n\n\n\nfinal\n \nclass\n \nUser\n:\n \nCodable\n \n{\n\n    \nvar\n \nid\n:\n \nUUID\n?\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nAlthough it's not necessary, adding \nfinal\n to your Swift classes can make them more performant\nand also make adding \ninit\n methods in extensions easier.\n\n\nConforming to Model\n\n\nNow that we have our \nUser\n class, let's conform it to \nModel\n.\n\n\nimport\n \nFluent\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n\n\n}\n\n\n\n\n\n\nOnce you add this conformance requirement, Swift will tell you that it does not yet conform.\nLet's add the necessary items to make \nUser\n conform to model.\n\n\n\n\nTip\n\n\nWe recommend adding \nModel\n conformance in an extension to help keep your code clean.\n\n\n\n\nDatabase\n\n\nThe first step to conforming to \nModel\n is to let Fluent know which type of database you plan\non using this model with. This allows Fluent to enable database-specific features wherever you\nuse this model.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentMySQL\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n \n\n    \n/// See Model.Database\n\n    \ntypealias\n \nDatabase\n \n=\n \nMySQLDatabase\n\n\n}\n\n\n\n\n\n\nID\n\n\nNow we can tell Fluent what type of ID this model uses. In this example, our \nUser\n model\nhas an ID property of type \nUUID\n named \nid\n.\n\n\nimport\n \nFluent\n\n\nimport\n \nFoundation\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n\n\n    \n/// See Model.ID\n\n    \ntypealias\n \nID\n \n=\n \nUUID\n\n\n    \n/// See Model.idKey\n\n    \nstatic\n \nvar\n \nidKey\n:\n \nIDKey\n \n{\n\n        \nreturn\n \n\\\n.\nid\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can use any type that conforms to \nIDType\n as a Fluent ID. See \nFluent \n Model \n ID\n for more information.\nYou can also use any property name you'd like for the id.\n\n\n\n\nWarning\n\n\nSome databases require certain ID keys. For example, MongoDB requires \n_id\n.\n\n\n\n\nKey Field Map\n\n\nIn order to prevent duplicate (and error-prone) strings throughout your code, Fluent models declare\na \nKeyFieldMap\n. This maps your model's properties to their respective database fields.\n\n\nimport\n \nFluent\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n\n\n    \n/// See Model.keyFieldMap\n\n    \nstatic\n \nvar\n \nkeyFieldMap\n:\n \nKeyFieldMap\n \n{\n\n        \nreturn\n \n[\n\n            \nkey\n(\n\\\n.\nid\n):\n \nfield\n(\nid\n),\n\n            \nkey\n(\n\\\n.\nname\n):\n \nfield\n(\nname\n),\n\n            \nkey\n(\n\\\n.\nage\n):\n \nfield\n(\nage\n),\n\n        \n]\n\n    \n}\n\n\n}\n\n\n\n\n\n\nKey paths are a type-safe way to declare references to your model's properties.\nYou can learn more about key paths in the Swift Evolution proposal, \nSE-0161\n.\n\n\n\n\nNote\n\n\nUnless you have a special use case, you should always \njust set the \nfield(...)\n and \nkey(...)\n as the same string.\n\n\n\n\nTo see what using these key paths looks like in action, check out \nFluent \n Getting Started \n Query\n.\n\n\nExample\n\n\nWe now have a fully-conformed Fluent model!\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFoundation\n\n\n\nfinal\n \nclass\n \nUser\n:\n \nCodable\n \n{\n\n    \nvar\n \nid\n:\n \nUUID\n?\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n/// See Model.Database\n\n    \ntypealias\n \nDatabase\n \n=\n \nMySQLDatabase\n\n\n    \n/// See Model.ID\n\n    \ntypealias\n \nID\n \n=\n \nUUID\n\n\n    \n/// See Model.idKey\n\n    \nstatic\n \nvar\n \nidKey\n:\n \nIDKey\n \n{\n\n        \nreturn\n \n\\\n.\nid\n\n    \n}\n\n\n    \n/// See Model.keyFieldMap\n\n    \nstatic\n \nvar\n \nkeyFieldMap\n:\n \nKeyFieldMap\n \n{\n\n        \nreturn\n \n[\n\n            \nkey\n(\n\\\n.\nid\n):\n \nfield\n(\nid\n),\n\n            \nkey\n(\n\\\n.\nname\n):\n \nfield\n(\nname\n),\n\n            \nkey\n(\n\\\n.\nage\n):\n \nfield\n(\nage\n),\n\n        \n]\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDone\n\n\nNow that you have a working Fluent model, you can move onto \nquerying\n your model. \nHowever, if your database uses schemas, you may need to create a \nmigration\n for your model first.", 
            "title": "Models"
        }, 
        {
            "location": "/fluent/getting-started/models/#getting-started-with-models", 
            "text": "Models are the heart of Fluent. Unlike ORMs in other languages, Fluent doesn't return untyped \narrays or dictionaries for queries. Instead, you query the database using models. This allows the \nSwift compiler to catch many errors that have burdened ORM users for ages.  In this guide, we will cover the creation of a basic  User  model. See  Fluent   Model  for\nmore in-depth information about the model protocol.", 
            "title": "Getting Started with Models"
        }, 
        {
            "location": "/fluent/getting-started/models/#class", 
            "text": "Every Fluent model starts with a  Codable  class. You can make any  Codable  class a Fluent model, \neven ones that come from a different module. All you have to do is conform to  Model .   import   Foundation  final   class   User :   Codable   { \n     var   id :   UUID ? \n     var   name :   String \n     var   age :   Int  }   Although it's not necessary, adding  final  to your Swift classes can make them more performant\nand also make adding  init  methods in extensions easier.", 
            "title": "Class"
        }, 
        {
            "location": "/fluent/getting-started/models/#conforming-to-model", 
            "text": "Now that we have our  User  class, let's conform it to  Model .  import   Fluent  extension   User :   Model   {  }   Once you add this conformance requirement, Swift will tell you that it does not yet conform.\nLet's add the necessary items to make  User  conform to model.   Tip  We recommend adding  Model  conformance in an extension to help keep your code clean.", 
            "title": "Conforming to Model"
        }, 
        {
            "location": "/fluent/getting-started/models/#database", 
            "text": "The first step to conforming to  Model  is to let Fluent know which type of database you plan\non using this model with. This allows Fluent to enable database-specific features wherever you\nuse this model.  import   Fluent  import   FluentMySQL  extension   User :   Model   { \n     ...  \n\n     /// See Model.Database \n     typealias   Database   =   MySQLDatabase  }", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/getting-started/models/#id", 
            "text": "Now we can tell Fluent what type of ID this model uses. In this example, our  User  model\nhas an ID property of type  UUID  named  id .  import   Fluent  import   Foundation  extension   User :   Model   { \n     ... \n\n     /// See Model.ID \n     typealias   ID   =   UUID \n\n     /// See Model.idKey \n     static   var   idKey :   IDKey   { \n         return   \\ . id \n     }  }   You can use any type that conforms to  IDType  as a Fluent ID. See  Fluent   Model   ID  for more information.\nYou can also use any property name you'd like for the id.   Warning  Some databases require certain ID keys. For example, MongoDB requires  _id .", 
            "title": "ID"
        }, 
        {
            "location": "/fluent/getting-started/models/#key-field-map", 
            "text": "In order to prevent duplicate (and error-prone) strings throughout your code, Fluent models declare\na  KeyFieldMap . This maps your model's properties to their respective database fields.  import   Fluent  extension   User :   Model   { \n     ... \n\n     /// See Model.keyFieldMap \n     static   var   keyFieldMap :   KeyFieldMap   { \n         return   [ \n             key ( \\ . id ):   field ( id ), \n             key ( \\ . name ):   field ( name ), \n             key ( \\ . age ):   field ( age ), \n         ] \n     }  }   Key paths are a type-safe way to declare references to your model's properties.\nYou can learn more about key paths in the Swift Evolution proposal,  SE-0161 .   Note  Unless you have a special use case, you should always \njust set the  field(...)  and  key(...)  as the same string.   To see what using these key paths looks like in action, check out  Fluent   Getting Started   Query .", 
            "title": "Key Field Map"
        }, 
        {
            "location": "/fluent/getting-started/models/#example", 
            "text": "We now have a fully-conformed Fluent model!  import   Fluent  import   FluentMySQL  import   Foundation  final   class   User :   Codable   { \n     var   id :   UUID ? \n     var   name :   String \n     var   age :   Int  }  extension   User :   Model   { \n     /// See Model.Database \n     typealias   Database   =   MySQLDatabase \n\n     /// See Model.ID \n     typealias   ID   =   UUID \n\n     /// See Model.idKey \n     static   var   idKey :   IDKey   { \n         return   \\ . id \n     } \n\n     /// See Model.keyFieldMap \n     static   var   keyFieldMap :   KeyFieldMap   { \n         return   [ \n             key ( \\ . id ):   field ( id ), \n             key ( \\ . name ):   field ( name ), \n             key ( \\ . age ):   field ( age ), \n         ] \n     }  }", 
            "title": "Example"
        }, 
        {
            "location": "/fluent/getting-started/models/#done", 
            "text": "Now that you have a working Fluent model, you can move onto  querying  your model. \nHowever, if your database uses schemas, you may need to create a  migration  for your model first.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/getting-started/migrations/", 
            "text": "Getting Started with Migrations\n\n\nMigrations are a way of making organized, testable, and reliable changes to your database's structure--\neven while it's in production!\n\n\nMigrations are often used for preparing a database schema for your models. However, they can also be used to \nmake normal queries to your database.\n\n\nIn this guide we will cover creating both types of migrations.\n\n\nModel Schema\n\n\nLet's take a look at how we can prepare a schema supporting database to accept the \n\nUser\n model from the \nprevious section\n.\n\n\nJust like we did with the \nModel\n protocol, we will conform our \nUser\n to \nMigration\n.\n\n\nimport\n \nFluent\n\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n\n\n}\n\n\n\n\n\n\nSwift will inform us that \nUser\n does not yet conform. Let's add the required methods!\n\n\nPrepare\n\n\nThe first method to implement is \nprepare\n. This method is where you make any of your \ndesired changes to the database.\n\n\nFor our \nUser\n model, we simply want to create a table that can store one or more users. To do this,\nwe will use the \n.create(...)\n function on the supplied database connection.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.prepare\n\n    \nstatic\n \nfunc\n \nprepare\n(\non\n \nconnection\n:\n \nMySQLConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ncreate\n(\nself\n)\n \n{\n \nbuilder\n \nin\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nid\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nname\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nage\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWe pass \nself\n (shorthand for \nUser.self\n since this is a static method) as the first argument to the \n.create\n method. This indicates\nto Fluent that we would like to create a schema for the \nUser\n model.\n\n\nNext, we pass a closure that accepts a \nSchemaBuilder\n for our \nUser\n model.\nWe can then call \n.field\non this builder to describe what fields we'd like our table to have.\n\n\nSince we are passing key paths to our \nUser\n model (indicated by \n\\.\n), Fluent can see what type those properties are.\nFor most common types (\nString\n, \nInt\n, \nDouble\n, etc) Fluent will automatically be able to determine the best\ndatabase field type to use.\n\n\nYou can also choose to manually select which database field type to use for a given field.\n\n\ntry\n \nbuilder\n.\nfield\n(\ntype\n:\n \n.\ntext\n,\n \nfor\n:\n \n\\\n.\nname\n)\n\n\n\n\n\n\nLearn more about creating, updating, and deleting schemas in \nFluent \n Schema Builder\n.\n\n\nRevert\n\n\nRevert is the opposite of prepare. It's job is to undo anything that was done in prepare. It is used when you boot your \napp with the \n--revert\n option. See \nFluent \n Migration\n for more information.\n\n\nTo implement \nrevert\n for our model, we simply use \n.delete\n to indicate that we would like to delete the schema created for \nUser\n.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.revert\n\n    \nstatic\n \nfunc\n \nrevert\n(\non\n \nconnection\n:\n \nMySQLConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ndelete\n(\nself\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExample\n\n\nWe now have a fully functioning model with migration!\n\n\nextension\n \nTestUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.prepare\n\n    \nstatic\n \nfunc\n \nprepare\n(\non\n \nconnection\n:\n \nSQLiteConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ncreate\n(\nself\n)\n \n{\n \nbuilder\n \nin\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nid\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nname\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nage\n)\n\n        \n}\n\n    \n}\n\n\n    \n/// See Migration.revert\n\n    \nstatic\n \nfunc\n \nrevert\n(\non\n \nconnection\n:\n \nSQLiteConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ndelete\n(\nself\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDone\n\n\nNow that you have a working Fluent model and migration, you can move onto \nquerying\n your model.", 
            "title": "Migrations"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#getting-started-with-migrations", 
            "text": "Migrations are a way of making organized, testable, and reliable changes to your database's structure--\neven while it's in production!  Migrations are often used for preparing a database schema for your models. However, they can also be used to \nmake normal queries to your database.  In this guide we will cover creating both types of migrations.", 
            "title": "Getting Started with Migrations"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#model-schema", 
            "text": "Let's take a look at how we can prepare a schema supporting database to accept the  User  model from the  previous section .  Just like we did with the  Model  protocol, we will conform our  User  to  Migration .  import   Fluent  extension   User :   Migration   {  }   Swift will inform us that  User  does not yet conform. Let's add the required methods!", 
            "title": "Model Schema"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#prepare", 
            "text": "The first method to implement is  prepare . This method is where you make any of your \ndesired changes to the database.  For our  User  model, we simply want to create a table that can store one or more users. To do this,\nwe will use the  .create(...)  function on the supplied database connection.  extension   User :   Migration   { \n     /// See Migration.prepare \n     static   func   prepare ( on   connection :   MySQLConnection )   -   Future Void   { \n         return   connection . create ( self )   {   builder   in \n             try   builder . field ( for :   \\ . id ) \n             try   builder . field ( for :   \\ . name ) \n             try   builder . field ( for :   \\ . age ) \n         } \n     }  }   We pass  self  (shorthand for  User.self  since this is a static method) as the first argument to the  .create  method. This indicates\nto Fluent that we would like to create a schema for the  User  model.  Next, we pass a closure that accepts a  SchemaBuilder  for our  User  model.\nWe can then call  .field on this builder to describe what fields we'd like our table to have.  Since we are passing key paths to our  User  model (indicated by  \\. ), Fluent can see what type those properties are.\nFor most common types ( String ,  Int ,  Double , etc) Fluent will automatically be able to determine the best\ndatabase field type to use.  You can also choose to manually select which database field type to use for a given field.  try   builder . field ( type :   . text ,   for :   \\ . name )   Learn more about creating, updating, and deleting schemas in  Fluent   Schema Builder .", 
            "title": "Prepare"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#revert", 
            "text": "Revert is the opposite of prepare. It's job is to undo anything that was done in prepare. It is used when you boot your \napp with the  --revert  option. See  Fluent   Migration  for more information.  To implement  revert  for our model, we simply use  .delete  to indicate that we would like to delete the schema created for  User .  extension   User :   Migration   { \n     /// See Migration.revert \n     static   func   revert ( on   connection :   MySQLConnection )   -   Future Void   { \n         return   connection . delete ( self ) \n     }  }", 
            "title": "Revert"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#example", 
            "text": "We now have a fully functioning model with migration!  extension   TestUser :   Migration   { \n     /// See Migration.prepare \n     static   func   prepare ( on   connection :   SQLiteConnection )   -   Future Void   { \n         return   connection . create ( self )   {   builder   in \n             try   builder . field ( for :   \\ . id ) \n             try   builder . field ( for :   \\ . name ) \n             try   builder . field ( for :   \\ . age ) \n         } \n     } \n\n     /// See Migration.revert \n     static   func   revert ( on   connection :   SQLiteConnection )   -   Future Void   { \n         return   connection . delete ( self ) \n     }  }", 
            "title": "Example"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#done", 
            "text": "Now that you have a working Fluent model and migration, you can move onto  querying  your model.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/getting-started/querying/", 
            "text": "Querying Models\n\n\nOnce you have a \nmodel\n (and optionally a \nmigration\n) you can start \nquerying your database to create, read, update, and delete data.\n\n\nConnection\n\n\nThe first thing you need to query your database, is a connection to it. Luckily, they are easy to get.\n\n\nYou can use either the application or an incoming request to create a database connection. You just need\naccess to the \nDatabaseIdentifier\n.\n\n\nRequest\n\n\nThe preferred method for getting access to a database connection is via an incoming request. \n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \nin\n\n        \n// use the db here\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first parameter is the database's \nidentifier\n. The second parameter is a closure\nthat accepts a connection to that database.\n\n\n\n\nTip\n\n\nAlthough the closure to \n.database(...)\n accepts a database \nconnection\n, we often use just \ndb\n for short.\n\n\n\n\nThe closure is expected to return a \nFuture\nVoid\n. When this future is completed, the connection will be released\nback into Fluent's connection pool. This is usually acheived by simply returning the query as we will soon see.\n\n\nApplication\n\n\nYou can also create a database connection using the application. This is useful for cases where you must access\nthe database from outside a request/response event.\n\n\nlet\n \nres\n \n=\n \napp\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \nin\n\n    \n// use the db here\n\n\n}\n\n\nprint\n(\nres\n)\n \n// Future\nT\n\n\n\n\n\n\nThis is usually done in the \nboot section\n of your application.\n\n\n\n\nWarning\n\n\nDo not use database connections created by the application in a route closure (when responding to a request).\nAlways use the incoming request to create a connection to avoid threading issues.\n\n\n\n\nCreate\n\n\nTo create (save) a model to the database, first initialize an instance of your model, then call \n.save(on: )\n.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nlet\n \nuser\n \n=\n \nUser\n(\nname\n:\n \nVapor\n,\n \nage\n:\n \n3\n)\n\n        \nreturn\n \nuser\n.\nsave\n(\non\n:\n \ndb\n).\nmap\n \n{\n \nuser\n \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nResponse\n\n\n.save(on: )\n returns a \nFuture\nVoid\n that completes when the user has finished saving. In this example, we then\nmap that \nFuture\nVoid\n to a \nFuture\nUser\n by calling \n.map\n and passing in the recently-saved user. \n\n\nYou can also use \n.map\n to return a simple success response.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nResponse\n \nin\n\n        \nlet\n \nuser\n \n=\n \nUser\n(\nname\n:\n \nVapor\n,\n \nage\n:\n \n3\n)\n\n        \nreturn\n \nuser\n.\nsave\n(\non\n:\n \ndb\n).\nmap\n \n{\n \n            \nreturn\n \nResponse\n(\nstatus\n:\n \n.\ncreated\n)\n \n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nMultiple\n\n\nIf you have multiple instances to save, do so using an array. Arrays containing only futures behave like futures.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nResponse\n \nin\n\n        \nlet\n \nmarie\n \n=\n \nUser\n(\nname\n:\n \nMarie Curie\n,\n \nage\n:\n \n66\n)\n\n        \nlet\n \ncharles\n \n=\n \nUser\n(\nname\n:\n \nCharles Darwin\n,\n \nage\n:\n \n73\n)\n\n        \nreturn\n \n[\n\n            \nmarie\n.\nsave\n(\non\n:\n \ndb\n),\n\n            \ncharles\n.\nsave\n(\non\n:\n \ndb\n)\n\n        \n].\nmap\n \n{\n\n            \nreturn\n \nResponse\n(\nstatus\n:\n \n.\ncreated\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRead\n\n\nTo read models from the database, use \n.query()\n on the database connection to create a \nQueryBuilder\n. \n\n\nAll\n\n\nFetch all instances of a model from the database using \n.all()\n.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\n[\nUser\n]\n \nin\n\n        \nreturn\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nall\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFilter\n\n\nUse \n.filter(...)\n to apply \nfilters\n to your query.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\n[\nUser\n]\n \nin\n\n        \nreturn\n \ntry\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfilter\n(\n\\\nUser\n.\nage\n \n \n50\n).\nall\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFirst\n\n\nYou can also use \n.first()\n to just get the first result.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nreturn\n \ntry\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfilter\n(\n\\\nUser\n.\nname\n \n==\n \nVapor\n).\nfirst\n().\nmap\n \n{\n \nuser\n \nin\n\n            \nguard\n \nlet\n \nuser\n \n=\n \nuser\n \nelse\n \n{\n\n                \nthrow\n \nAbort\n(.\nnotFound\n,\n \nreason\n:\n \nCould not find user.\n)\n\n            \n}\n\n\n            \nreturn\n \nuser\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNotice we use \n.map()\n here to convert the optional user returned by \n.first()\n to a non-optional\nuser, or we throw an error.\n\n\nUpdate\n\n\nComing soon.\n\n\nDelete\n\n\nComing soon.", 
            "title": "Querying"
        }, 
        {
            "location": "/fluent/getting-started/querying/#querying-models", 
            "text": "Once you have a  model  (and optionally a  migration ) you can start \nquerying your database to create, read, update, and delete data.", 
            "title": "Querying Models"
        }, 
        {
            "location": "/fluent/getting-started/querying/#connection", 
            "text": "The first thing you need to query your database, is a connection to it. Luckily, they are easy to get.  You can use either the application or an incoming request to create a database connection. You just need\naccess to the  DatabaseIdentifier .", 
            "title": "Connection"
        }, 
        {
            "location": "/fluent/getting-started/querying/#request", 
            "text": "The preferred method for getting access to a database connection is via an incoming request.   router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   in \n         // use the db here \n     }  }   The first parameter is the database's  identifier . The second parameter is a closure\nthat accepts a connection to that database.   Tip  Although the closure to  .database(...)  accepts a database  connection , we often use just  db  for short.   The closure is expected to return a  Future Void . When this future is completed, the connection will be released\nback into Fluent's connection pool. This is usually acheived by simply returning the query as we will soon see.", 
            "title": "Request"
        }, 
        {
            "location": "/fluent/getting-started/querying/#application", 
            "text": "You can also create a database connection using the application. This is useful for cases where you must access\nthe database from outside a request/response event.  let   res   =   app . database (. foo )   {   db   in \n     // use the db here  }  print ( res )   // Future T   This is usually done in the  boot section  of your application.   Warning  Do not use database connections created by the application in a route closure (when responding to a request).\nAlways use the incoming request to create a connection to avoid threading issues.", 
            "title": "Application"
        }, 
        {
            "location": "/fluent/getting-started/querying/#create", 
            "text": "To create (save) a model to the database, first initialize an instance of your model, then call  .save(on: ) .  router . post (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future User   in \n         let   user   =   User ( name :   Vapor ,   age :   3 ) \n         return   user . save ( on :   db ). map   {   user   } \n     }  }", 
            "title": "Create"
        }, 
        {
            "location": "/fluent/getting-started/querying/#response", 
            "text": ".save(on: )  returns a  Future Void  that completes when the user has finished saving. In this example, we then\nmap that  Future Void  to a  Future User  by calling  .map  and passing in the recently-saved user.   You can also use  .map  to return a simple success response.  router . post (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future Response   in \n         let   user   =   User ( name :   Vapor ,   age :   3 ) \n         return   user . save ( on :   db ). map   {  \n             return   Response ( status :   . created )  \n         } \n     }  }", 
            "title": "Response"
        }, 
        {
            "location": "/fluent/getting-started/querying/#multiple", 
            "text": "If you have multiple instances to save, do so using an array. Arrays containing only futures behave like futures.  router . post (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future Response   in \n         let   marie   =   User ( name :   Marie Curie ,   age :   66 ) \n         let   charles   =   User ( name :   Charles Darwin ,   age :   73 ) \n         return   [ \n             marie . save ( on :   db ), \n             charles . save ( on :   db ) \n         ]. map   { \n             return   Response ( status :   . created ) \n         } \n     }  }", 
            "title": "Multiple"
        }, 
        {
            "location": "/fluent/getting-started/querying/#read", 
            "text": "To read models from the database, use  .query()  on the database connection to create a  QueryBuilder .", 
            "title": "Read"
        }, 
        {
            "location": "/fluent/getting-started/querying/#all", 
            "text": "Fetch all instances of a model from the database using  .all() .  router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future [ User ]   in \n         return   db . query ( User . self ). all () \n     }  }", 
            "title": "All"
        }, 
        {
            "location": "/fluent/getting-started/querying/#filter", 
            "text": "Use  .filter(...)  to apply  filters  to your query.  router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future [ User ]   in \n         return   try   db . query ( User . self ). filter ( \\ User . age     50 ). all () \n     }  }", 
            "title": "Filter"
        }, 
        {
            "location": "/fluent/getting-started/querying/#first", 
            "text": "You can also use  .first()  to just get the first result.  router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future User   in \n         return   try   db . query ( User . self ). filter ( \\ User . name   ==   Vapor ). first (). map   {   user   in \n             guard   let   user   =   user   else   { \n                 throw   Abort (. notFound ,   reason :   Could not find user. ) \n             } \n\n             return   user \n         } \n     }  }   Notice we use  .map()  here to convert the optional user returned by  .first()  to a non-optional\nuser, or we throw an error.", 
            "title": "First"
        }, 
        {
            "location": "/fluent/getting-started/querying/#update", 
            "text": "Coming soon.", 
            "title": "Update"
        }, 
        {
            "location": "/fluent/getting-started/querying/#delete", 
            "text": "Coming soon.", 
            "title": "Delete"
        }, 
        {
            "location": "/fluent/database/", 
            "text": "Fluent Database\n\n\nComing soon.\n\n\nConnection\n\n\nComing soon.\n\n\nLogger\n\n\nComing soon.", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/database/#fluent-database", 
            "text": "Coming soon.", 
            "title": "Fluent Database"
        }, 
        {
            "location": "/fluent/database/#connection", 
            "text": "Coming soon.", 
            "title": "Connection"
        }, 
        {
            "location": "/fluent/database/#logger", 
            "text": "Coming soon.", 
            "title": "Logger"
        }, 
        {
            "location": "/fluent/model/", 
            "text": "Fluent Model\n\n\nComing soon.", 
            "title": "Model"
        }, 
        {
            "location": "/fluent/model/#fluent-model", 
            "text": "Coming soon.", 
            "title": "Fluent Model"
        }, 
        {
            "location": "/fluent/query-builder/", 
            "text": "Fluent Query Builder\n\n\nComing soon.\n\n\nFilter\n\n\nComing soon.\n\n\nCompare\n\n\nComing soon.\n\n\nGroup\n\n\nComing soon.\n\n\nSubset\n\n\nComing soon.\n\n\nJoin\n\n\nComing soon.\n\n\nRange\n\n\nComing soon.\n\n\nSort\n\n\nComing soon.\n\n\nExecute\n\n\nComing soon.\n\n\nAggregate\n\n\nComing soon.\n\n\nAll\n\n\nComing soon.\n\n\nFirst\n\n\nComing soon.\n\n\nQuery\n\n\nComing soon.", 
            "title": "Query Builder"
        }, 
        {
            "location": "/fluent/query-builder/#fluent-query-builder", 
            "text": "Coming soon.", 
            "title": "Fluent Query Builder"
        }, 
        {
            "location": "/fluent/query-builder/#filter", 
            "text": "Coming soon.", 
            "title": "Filter"
        }, 
        {
            "location": "/fluent/query-builder/#compare", 
            "text": "Coming soon.", 
            "title": "Compare"
        }, 
        {
            "location": "/fluent/query-builder/#group", 
            "text": "Coming soon.", 
            "title": "Group"
        }, 
        {
            "location": "/fluent/query-builder/#subset", 
            "text": "Coming soon.", 
            "title": "Subset"
        }, 
        {
            "location": "/fluent/query-builder/#join", 
            "text": "Coming soon.", 
            "title": "Join"
        }, 
        {
            "location": "/fluent/query-builder/#range", 
            "text": "Coming soon.", 
            "title": "Range"
        }, 
        {
            "location": "/fluent/query-builder/#sort", 
            "text": "Coming soon.", 
            "title": "Sort"
        }, 
        {
            "location": "/fluent/query-builder/#execute", 
            "text": "Coming soon.", 
            "title": "Execute"
        }, 
        {
            "location": "/fluent/query-builder/#aggregate", 
            "text": "Coming soon.", 
            "title": "Aggregate"
        }, 
        {
            "location": "/fluent/query-builder/#all", 
            "text": "Coming soon.", 
            "title": "All"
        }, 
        {
            "location": "/fluent/query-builder/#first", 
            "text": "Coming soon.", 
            "title": "First"
        }, 
        {
            "location": "/fluent/query-builder/#query", 
            "text": "Coming soon.", 
            "title": "Query"
        }, 
        {
            "location": "/fluent/migration/", 
            "text": "Fluent Migration\n\n\nComing soon.\n\n\nProtocol\n\n\nComing soon.\n\n\nConfig\n\n\nComing soon.", 
            "title": "Migration"
        }, 
        {
            "location": "/fluent/migration/#fluent-migration", 
            "text": "Coming soon.", 
            "title": "Fluent Migration"
        }, 
        {
            "location": "/fluent/migration/#protocol", 
            "text": "Coming soon.", 
            "title": "Protocol"
        }, 
        {
            "location": "/fluent/migration/#config", 
            "text": "Coming soon.", 
            "title": "Config"
        }, 
        {
            "location": "/fluent/schema-builder/", 
            "text": "Fluent Schema Builder\n\n\nComing soon.\n\n\nCreate\n\n\nComing soon.\n\n\nUpdate\n\n\nComing soon.\n\n\nDelete\n\n\nComing soon.\n\n\nReferences\n\n\nComing soon.", 
            "title": "Schema Builder"
        }, 
        {
            "location": "/fluent/schema-builder/#fluent-schema-builder", 
            "text": "Coming soon.", 
            "title": "Fluent Schema Builder"
        }, 
        {
            "location": "/fluent/schema-builder/#create", 
            "text": "Coming soon.", 
            "title": "Create"
        }, 
        {
            "location": "/fluent/schema-builder/#update", 
            "text": "Coming soon.", 
            "title": "Update"
        }, 
        {
            "location": "/fluent/schema-builder/#delete", 
            "text": "Coming soon.", 
            "title": "Delete"
        }, 
        {
            "location": "/fluent/schema-builder/#references", 
            "text": "Coming soon.", 
            "title": "References"
        }, 
        {
            "location": "/fluent/relations/", 
            "text": "Fluent Relations\n\n\nComing soon.\n\n\nParent / Child\n\n\nComing soon.\n\n\nSiblings\n\n\nComing soon.", 
            "title": "Relations"
        }, 
        {
            "location": "/fluent/relations/#fluent-relations", 
            "text": "Coming soon.", 
            "title": "Fluent Relations"
        }, 
        {
            "location": "/fluent/relations/#parent-child", 
            "text": "Coming soon.", 
            "title": "Parent / Child"
        }, 
        {
            "location": "/fluent/relations/#siblings", 
            "text": "Coming soon.", 
            "title": "Siblings"
        }, 
        {
            "location": "/fluent/pivot/", 
            "text": "Fluent Pivot\n\n\nComing soon.", 
            "title": "Pivot"
        }, 
        {
            "location": "/fluent/pivot/#fluent-pivot", 
            "text": "Coming soon.", 
            "title": "Fluent Pivot"
        }, 
        {
            "location": "/fluent/transaction/", 
            "text": "Fluent Transactions\n\n\nComing soon.", 
            "title": "Transaction"
        }, 
        {
            "location": "/fluent/transaction/#fluent-transactions", 
            "text": "Coming soon.", 
            "title": "Fluent Transactions"
        }, 
        {
            "location": "/databases/sqlite/package/", 
            "text": "Using SQLite\n\n\nThe \nvapor/sqlite\n package is a lightweight, nonblocking/async wrapper around SQLite 3's C API. It provides an intuitive Swift interface for working with SQLite that can be used with any Swift project.\n\n\nOn top of \nvapor/sqlite\n, we have built \nvapor/fluent-sqlite\n which allows SQLite databases to be used with Fluent.\n\n\nWith Fluent\n\n\nSQLite works great with Fluent, you just need to make sure to add the \nvapor/fluent-sqlite\n \npackage to your project.\n\n\nTo do this, add the Fluent SQLite package to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/fluent-sqlite.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nFluentSQLite\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport FluentSQLite\n to access SQLite's Fluent compatible APIs.\n\n\nJust SQLite\n\n\nThis package was built to be a powerful interface for SQLite whether or not you use Fluent. To include this SQLite package in your project, simply add it to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/sqlite.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nAsync\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport SQLite\n to access the Swift SQLite APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/databases/sqlite/package/#using-sqlite", 
            "text": "The  vapor/sqlite  package is a lightweight, nonblocking/async wrapper around SQLite 3's C API. It provides an intuitive Swift interface for working with SQLite that can be used with any Swift project.  On top of  vapor/sqlite , we have built  vapor/fluent-sqlite  which allows SQLite databases to be used with Fluent.", 
            "title": "Using SQLite"
        }, 
        {
            "location": "/databases/sqlite/package/#with-fluent", 
            "text": "SQLite works great with Fluent, you just need to make sure to add the  vapor/fluent-sqlite  \npackage to your project.  To do this, add the Fluent SQLite package to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/fluent-sqlite.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ FluentSQLite ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import FluentSQLite  to access SQLite's Fluent compatible APIs.", 
            "title": "With Fluent"
        }, 
        {
            "location": "/databases/sqlite/package/#just-sqlite", 
            "text": "This package was built to be a powerful interface for SQLite whether or not you use Fluent. To include this SQLite package in your project, simply add it to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/sqlite.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Async ,   ...   ]) \n     ]  )   Use  import SQLite  to access the Swift SQLite APIs.", 
            "title": "Just SQLite"
        }, 
        {
            "location": "/databases/sqlite/overview/", 
            "text": "SQLite Overview\n\n\nLet's dive into the \nvapor/sqlite\n package and \nsee how to connect to and query a database.\n\n\n\n\nWarning\n\n\nThis documentation provides an overview for the SQLite API. \nIf you are using SQLite with Fluent, you will likely never need to use\nthis API. Use \nFluent's APIs\n instead.\n\n\n\n\nFollow the instructions in the \npackage\n section to add the SQLite package to your project. Once its added, you should be able to use \nimport SQLite.\n\n\nDatabase\n\n\nThe first step to making a query is to create a \nDatabase\n.\n\n\nIn Memory\n\n\nIn-memory SQLite databases are great for testing as they aren't persisted between application boots.\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nmemory\n)\n\n\n\n\n\n\nFile path\n\n\nSQLite requires a single file to persist the database contents.\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nfile\n(\npath\n:\n \n/tmp/db.sqlite\n))\n\n\n\n\n\n\n\n\nTip\n\n\nIf the database file does not already exist, it will be created.\n\n\n\n\nConnection\n\n\nOnce you have initialized your database, you can create a connection.\n\n\nlet\n \nconn\n \n=\n \ntry\n \ndb\n.\nmakeConnection\n(\non\n:\n \n.\nglobal\n())\n\n\n\n\n\n\n\n\nNote\n\n\nPay special attention to which \nDispatchQueue\n you pass to \nmakeConnection(on:)\n. \nThis will be the queue SQLite calls you back on.\n\n\n\n\n\n\nTip\n\n\nIf you are using SQLite with Vapor, make sure to pass the \nworker\n's queue here.\n\n\n\n\nQuery\n\n\nOnce you have a \nConnection\n, you can use it to create a \nQuery\n.\n\n\nlet\n \nquery\n \n=\n \nconn\n.\nquery\n(\nSELECT * FROM users\n)\n\n\n\n\n\n\nBinding Values\n\n\nIf you are executing a query that has input values, you should bind these using parameters. \n\n\nlet\n \nquery\n \n=\n \nconn\n.\nquery\n(\nINSERT INTO users (name, age) VALUES (?, ?)\n)\n\n\nquery\n.\nbind\n(\nAlbert\n)\n\n\nquery\n.\nbind\n(\n138\n)\n\n\n\n\n\n\nYou can also bind values using method chaining.\n\n\nlet\n \nquery\n \n=\n \nconn\n.\nquery\n(\nINSERT INTO users (name, age) VALUES (?, ?)\n)\n\n    \n.\nbind\n(\nAlbert\n)\n\n    \n.\nbind\n(\n138\n)\n\n\n\n\n\n\nOutput Stream\n\n\nIf you expect output from your query, you must attach a stream. The easiest way\nto do this is by using the \ndrain\n convenience.\n\n\nquery\n.\ndrain\n \n{\n \nrow\n \nin\n\n    \nprint\n(\nrow\n)\n\n\n}\n\n\n\n\n\n\nYou can also use \ndrain(into:)\n and pass in a custom \nInputStream\n to capture the query's results.\n\n\nRow\n\n\nThe \nQuery\n will output \nRow\ns. These are simple structs.\n\n\nstruct\n \nRow\n \n{\n\n    \nvar\n \nfields\n:\n \n[\nString\n:\n \nField\n]\n\n    \nsubscript\n(\nfield\n:\n \nString\n)\n \n-\n \nData\n?\n \n{\n \nget\n \n}\n\n\n}\n\n\n\n\n\n\nYou can subscript a \nRow\n object to get the optional \nData\n.\n\n\nlet\n \nnameData\n \n=\n \nrow\n[\nname\n]\n \n// Data?\n\n\n\n\n\n\nData\n is an enum that contains all possible types of SQLite data.\n\n\npublic\n \nenum\n \nData\n \n{\n\n    \ncase\n \ninteger\n(\nInt\n)\n\n    \ncase\n \nfloat\n(\nDouble\n)\n\n    \ncase\n \ntext\n(\nString\n)\n\n    \ncase\n \nblob\n(\nFoundation\n.\nData\n)\n\n    \ncase\n \nnull\n\n\n}\n\n\n\n\n\n\nFor each option, there are convenience properties for casting the \nData\n enum.\n\n\nlet\n \nname\n \n=\n \nrow\n[\nname\n]?.\ntext\n \n// String\n\n\n\n\n\n\nRun\n\n\nOnce your query is ready to execute, you simply call \n.execute()\n. This returns a \nFuture\nVoid\n \nthat will be completed when the query is done executing.\n\n\nquery\n.\nexecute\n().\nthen\n \n{\n\n    \nprint\n(\ndone!\n)\n\n\n}\n\n\n\n\n\n\nAll\n\n\nIf you simply want to fetch all of the results, you can use the \n.all()\n convenience.\nThis will automatically create a stream and return a future containing your results.\n\n\nquery\n.\nall\n().\nthen\n \n{\n \nrows\n \nin\n\n    \nprint\n(\nrows\n)\n\n\n}\n\n\n\n\n\n\nSync\n\n\nFor situations where blocking is appropriate (perhaps in tests) you can use \n.sync()\n to block\nuntil the query's results are ready and return them directly.\n\n\n// don\nt do this unless blocking is OK\n\n\nlet\n \nrows\n \n=\n \ntry\n \nconn\n.\nquery\n(\nSELECT * FROM users\n).\nsync\n()\n\n\n\n\n\n\nExample\n\n\nNow for the complete example: \n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nmemory\n)\n\n\nlet\n \nconn\n \n=\n \ntry\n \ndb\n.\nmakeConnection\n(\non\n:\n \n.\nglobal\n())\n \n// take care to use correct queue\n\n\nconn\n.\nquery\n(\nSELECT * FROM users\n)\n\n    \n.\nall\n()\n\n    \n.\nthen\n \n{\n \nrows\n \nin\n\n        \nprint\n(\nrows\n)\n\n    \n}\n\n    \n.\ncatch\n \n{\n \nerr\n \nin\n\n        \nprint\n(\nerr\n)\n\n    \n}\n\n\n\n// wait for results\n\n\n\n\n\n\nAn example with values being bound:\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nmemory\n)\n\n\nlet\n \nconn\n \n=\n \ntry\n \ndb\n.\nmakeConnection\n(\non\n:\n \n.\nglobal\n())\n \n// take care to use correct queue\n\n\nconn\n.\nquery\n(\nINSERT INTO users (name, age) VALUES (?, ?)\n)\n\n    \n.\nbind\n(\nAlbert\n)\n\n    \n.\nbind\n(\n138\n)\n\n    \n.\nexecute\n()\n\n    \n.\nthen\n \n{\n\n        \nprint\n(\ndone\n)\n\n    \n}\n\n    \n.\ncatch\n \n{\n \nerr\n \nin\n\n        \nprint\n(\nerr\n)\n\n    \n}\n\n\n\n// wait for results", 
            "title": "Overview"
        }, 
        {
            "location": "/databases/sqlite/overview/#sqlite-overview", 
            "text": "Let's dive into the  vapor/sqlite  package and \nsee how to connect to and query a database.   Warning  This documentation provides an overview for the SQLite API. \nIf you are using SQLite with Fluent, you will likely never need to use\nthis API. Use  Fluent's APIs  instead.   Follow the instructions in the  package  section to add the SQLite package to your project. Once its added, you should be able to use  import SQLite.", 
            "title": "SQLite Overview"
        }, 
        {
            "location": "/databases/sqlite/overview/#database", 
            "text": "The first step to making a query is to create a  Database .", 
            "title": "Database"
        }, 
        {
            "location": "/databases/sqlite/overview/#in-memory", 
            "text": "In-memory SQLite databases are great for testing as they aren't persisted between application boots.  import   SQLite  let   db   =   Database ( storage :   . memory )", 
            "title": "In Memory"
        }, 
        {
            "location": "/databases/sqlite/overview/#file-path", 
            "text": "SQLite requires a single file to persist the database contents.  import   SQLite  let   db   =   Database ( storage :   . file ( path :   /tmp/db.sqlite ))    Tip  If the database file does not already exist, it will be created.", 
            "title": "File path"
        }, 
        {
            "location": "/databases/sqlite/overview/#connection", 
            "text": "Once you have initialized your database, you can create a connection.  let   conn   =   try   db . makeConnection ( on :   . global ())    Note  Pay special attention to which  DispatchQueue  you pass to  makeConnection(on:) . \nThis will be the queue SQLite calls you back on.    Tip  If you are using SQLite with Vapor, make sure to pass the  worker 's queue here.", 
            "title": "Connection"
        }, 
        {
            "location": "/databases/sqlite/overview/#query", 
            "text": "Once you have a  Connection , you can use it to create a  Query .  let   query   =   conn . query ( SELECT * FROM users )", 
            "title": "Query"
        }, 
        {
            "location": "/databases/sqlite/overview/#binding-values", 
            "text": "If you are executing a query that has input values, you should bind these using parameters.   let   query   =   conn . query ( INSERT INTO users (name, age) VALUES (?, ?) )  query . bind ( Albert )  query . bind ( 138 )   You can also bind values using method chaining.  let   query   =   conn . query ( INSERT INTO users (name, age) VALUES (?, ?) ) \n     . bind ( Albert ) \n     . bind ( 138 )", 
            "title": "Binding Values"
        }, 
        {
            "location": "/databases/sqlite/overview/#output-stream", 
            "text": "If you expect output from your query, you must attach a stream. The easiest way\nto do this is by using the  drain  convenience.  query . drain   {   row   in \n     print ( row )  }   You can also use  drain(into:)  and pass in a custom  InputStream  to capture the query's results.", 
            "title": "Output Stream"
        }, 
        {
            "location": "/databases/sqlite/overview/#row", 
            "text": "The  Query  will output  Row s. These are simple structs.  struct   Row   { \n     var   fields :   [ String :   Field ] \n     subscript ( field :   String )   -   Data ?   {   get   }  }   You can subscript a  Row  object to get the optional  Data .  let   nameData   =   row [ name ]   // Data?   Data  is an enum that contains all possible types of SQLite data.  public   enum   Data   { \n     case   integer ( Int ) \n     case   float ( Double ) \n     case   text ( String ) \n     case   blob ( Foundation . Data ) \n     case   null  }   For each option, there are convenience properties for casting the  Data  enum.  let   name   =   row [ name ]?. text   // String", 
            "title": "Row"
        }, 
        {
            "location": "/databases/sqlite/overview/#run", 
            "text": "Once your query is ready to execute, you simply call  .execute() . This returns a  Future Void  \nthat will be completed when the query is done executing.  query . execute (). then   { \n     print ( done! )  }", 
            "title": "Run"
        }, 
        {
            "location": "/databases/sqlite/overview/#all", 
            "text": "If you simply want to fetch all of the results, you can use the  .all()  convenience.\nThis will automatically create a stream and return a future containing your results.  query . all (). then   {   rows   in \n     print ( rows )  }", 
            "title": "All"
        }, 
        {
            "location": "/databases/sqlite/overview/#sync", 
            "text": "For situations where blocking is appropriate (perhaps in tests) you can use  .sync()  to block\nuntil the query's results are ready and return them directly.  // don t do this unless blocking is OK  let   rows   =   try   conn . query ( SELECT * FROM users ). sync ()", 
            "title": "Sync"
        }, 
        {
            "location": "/databases/sqlite/overview/#example", 
            "text": "Now for the complete example:   import   SQLite  let   db   =   Database ( storage :   . memory )  let   conn   =   try   db . makeConnection ( on :   . global ())   // take care to use correct queue  conn . query ( SELECT * FROM users ) \n     . all () \n     . then   {   rows   in \n         print ( rows ) \n     } \n     . catch   {   err   in \n         print ( err ) \n     }  // wait for results   An example with values being bound:  import   SQLite  let   db   =   Database ( storage :   . memory )  let   conn   =   try   db . makeConnection ( on :   . global ())   // take care to use correct queue  conn . query ( INSERT INTO users (name, age) VALUES (?, ?) ) \n     . bind ( Albert ) \n     . bind ( 138 ) \n     . execute () \n     . then   { \n         print ( done ) \n     } \n     . catch   {   err   in \n         print ( err ) \n     }  // wait for results", 
            "title": "Example"
        }, 
        {
            "location": "/databases/mysql/package/", 
            "text": "MySQL Package\n\n\nComing soon.", 
            "title": "Package"
        }, 
        {
            "location": "/databases/mysql/package/#mysql-package", 
            "text": "Coming soon.", 
            "title": "MySQL Package"
        }, 
        {
            "location": "/databases/mysql/", 
            "text": "MySQL\n\n\nThis package is a driver for the \nMySQL Database\n, an \nRDBMS\n oriented towards stability and robustness.\n\n\nThis driver supports both MySQL and MariaDB. These two databases are almost identical towards the user.\n\n\n\n\nWarning\n\n\nThis documentation provides an overview for the MySQL API.\nIf you are using MySQL with Fluent, you will likely never need to use\nthis API. Use \nFluent's APIs\n instead.\n\n\n\n\nIndex\n\n\n\n\nSetup\n\n\nBasics\n\n\n\n\nPackage.swift\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/mysql.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nMySQL\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport MySQL\n to access MySQL' APIs.", 
            "title": "Index"
        }, 
        {
            "location": "/databases/mysql/#mysql", 
            "text": "This package is a driver for the  MySQL Database , an  RDBMS  oriented towards stability and robustness.  This driver supports both MySQL and MariaDB. These two databases are almost identical towards the user.   Warning  This documentation provides an overview for the MySQL API.\nIf you are using MySQL with Fluent, you will likely never need to use\nthis API. Use  Fluent's APIs  instead.", 
            "title": "MySQL"
        }, 
        {
            "location": "/databases/mysql/#index", 
            "text": "Setup  Basics", 
            "title": "Index"
        }, 
        {
            "location": "/databases/mysql/#packageswift", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/mysql.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ MySQL ,   ...   ]) \n     ]  )   Use  import MySQL  to access MySQL' APIs.", 
            "title": "Package.swift"
        }, 
        {
            "location": "/databases/mysql/setup/", 
            "text": "MySQL Setup\n\n\nThis page guides you through installing and connecting to MySQL or MariaDB.\n\n\nInstallation\n\n\nFirst, you need to install MySQL on your server or test environment.\n\n\nUbuntu\n\n\nUbuntu has a thorough guide \nhere\n outlining both basic installation, configuration as well as advanced configurations.\n\n\nmacOS\n\n\nAssuming you've installed \nhomebrew\n you can use the following command to set up MySQL.\n\n\nbrew install mysql\n\n\n\n\n\nAny issues and further configuration will be explained in the terminal on completion of the installation.\n\n\nConnecting\n\n\nThe MySQL driver works with an automatically managed connection pool.\n\n\nThe following code creates a new connectionpool to \nlocalhost\n and the default MySQL port. The user that's being authenticated with is \nroot\n and the password is \nnil\n for \"no password\". If you do set a password, even if it's empty \n\"\"\n it will be treated differently. Users without a password must specify \nnil\n and must not specify \n\"\"\n.\n\n\nThe database is the database that is selected and authenticated to. Any future queries will be sent to this database.\n\n\nThe \nworker\n is defined in \nthe async documentation\n.\n\n\nlet\n \nconnectionPool\n \n=\n \nConnectionPool\n(\nhostname\n:\n \nlocalhost\n,\n \nuser\n:\n \nroot\n,\n \npassword\n:\n \nnil\n,\n \ndatabase\n:\n \ntest-db\n,\n \nworker\n:\n \nworker\n)\n\n\n\n\n\n\nCreating a connection pool successfully does not imply that the configuration is correct. The (first) query's success or failure will indicate the successful or unsuccessful connection. This way the API stays much simpler than it would otherwise be.\n\n\nLearn how you can execute queries here", 
            "title": "Setup"
        }, 
        {
            "location": "/databases/mysql/setup/#mysql-setup", 
            "text": "This page guides you through installing and connecting to MySQL or MariaDB.", 
            "title": "MySQL Setup"
        }, 
        {
            "location": "/databases/mysql/setup/#installation", 
            "text": "First, you need to install MySQL on your server or test environment.", 
            "title": "Installation"
        }, 
        {
            "location": "/databases/mysql/setup/#ubuntu", 
            "text": "Ubuntu has a thorough guide  here  outlining both basic installation, configuration as well as advanced configurations.", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/databases/mysql/setup/#macos", 
            "text": "Assuming you've installed  homebrew  you can use the following command to set up MySQL.  brew install mysql  Any issues and further configuration will be explained in the terminal on completion of the installation.", 
            "title": "macOS"
        }, 
        {
            "location": "/databases/mysql/setup/#connecting", 
            "text": "The MySQL driver works with an automatically managed connection pool.  The following code creates a new connectionpool to  localhost  and the default MySQL port. The user that's being authenticated with is  root  and the password is  nil  for \"no password\". If you do set a password, even if it's empty  \"\"  it will be treated differently. Users without a password must specify  nil  and must not specify  \"\" .  The database is the database that is selected and authenticated to. Any future queries will be sent to this database.  The  worker  is defined in  the async documentation .  let   connectionPool   =   ConnectionPool ( hostname :   localhost ,   user :   root ,   password :   nil ,   database :   test-db ,   worker :   worker )   Creating a connection pool successfully does not imply that the configuration is correct. The (first) query's success or failure will indicate the successful or unsuccessful connection. This way the API stays much simpler than it would otherwise be.  Learn how you can execute queries here", 
            "title": "Connecting"
        }, 
        {
            "location": "/databases/mysql/basics/", 
            "text": "MySQL Basics\n\n\nThis guide assumes you've set up MySQL and are connected to MySQL using a connection pool as described in \nthe setup guide\n.\n\n\nType safety\n\n\nThe MySQL driver is written to embrace type-safety and Codable. We currently \nonly\n expose Codable based results until we've found a good design for the non-codable API.\n\n\nQueries\n\n\nQueries are any type conforming to the protocol \nQuery\n, which requires being convertible to a \nString\n.\n\nString\n is a Query by default.\n\n\nYou can receive results from Queries in 3 kinds of formats.\n\n\n\n\nStream\n\n\nFuture\n\n\nforEach\n\n\n\n\nAll examples assume the following model:\n\n\nstruct\n \nUser\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n  \nvar\n \npasswordHash\n:\n \nString\n\n  \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nStreams\n\n\nStreams, \nas described on this page\n, are a source of information that calls a single reader's callback. Streams are best used in larger datasets to prevent the query from consuming a large amount of memory. The downside of a stream is that you cannot return all results in a single future. You'll need to stream the results to the other endpoint, too. For HTTP \nthis is described here.\n\n\nQuerying a database for a stream of results is achieved through the \nstream\n function and requires specifying the \nDecodable\n type that the results need to be deserialized into.\n\n\n \n// `ModelStream\nUser\n`\n\n\nlet\n \nusersStream\n \n=\n \nconnectionPool\n.\nstream\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n\n\n\n\n\n\nThis stream will return all results in the ModelStream's output callback which you can drain. You can register a callback on \nusersStream.onClose\n that will trigger when the end of the \nModelStream\n has been reached.\n\n\nFutures\n\n\nFutures are often easier to use but significantly heavier on your memory and thus performance. \nThey are thoroughly described here\n\n\nQuerying a database for a future is achieved through the \nall\n function and requires specifying the \nDecodable\n type that the results need to be deserialized into.\n\n\n \n// Future\n[User]\n\n\nlet\n \nusers\n \n=\n \nconnectionPool\n.\nall\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n\n\n\n\n\n\nFor partial results (\nSELECT username, age FROM\n) it is recommended to create a second decodable struct specifically for this query to ensure correctness and type-safety.\n\n\nstruct\n \nUserLoginDetails\n:\n \nDecodable\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n  \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nForEach\n\n\nIf you don't need to stream complex results to a third party such as using an HTTP Response you can use \nforEach\n. This is particularly useful for asynchronous actions such as sending a lot of email to the results of a query without depending on the completion/success of one email for the next email.\n\n\nconnectionPool\n.\nforEach\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n}\n\n\n\n\n\n\nforEach\n returns a future that you can optionally capture. It will be completed when all users have been processed.\n\n\nlet\n \ncompleted\n \n=\n \nconnectionPool\n.\nforEach\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n}\n\n\n\ncompleted\n.\nthen\n \n{\n\n  \nprint\n(\nAll users printed\n)\n\n\n}\n\n\n\n\n\n\nResultless queries\n\n\nSome queries (mostly administrative queries) do not require/return a response. Instead, they only indicate success or error.\n\n\nYou can execute these queries using the \nquery\n command.\n\n\nconnectionPool\n.\nquery\n(\nDROP TABLE users\n)\n\n\n\n\n\n\nYou can handle success or response using the returned future.\n\n\nconnectionPool\n.\nquery\n(\nDROP TABLE users\n).\nthen\n \n{\n\n  \nprint\n(\nsuccess\n)\n\n\n}.\ncatch\n \n{\n\n  \nprint\n(\nfailure\n)\n\n\n}", 
            "title": "Basics"
        }, 
        {
            "location": "/databases/mysql/basics/#mysql-basics", 
            "text": "This guide assumes you've set up MySQL and are connected to MySQL using a connection pool as described in  the setup guide .", 
            "title": "MySQL Basics"
        }, 
        {
            "location": "/databases/mysql/basics/#type-safety", 
            "text": "The MySQL driver is written to embrace type-safety and Codable. We currently  only  expose Codable based results until we've found a good design for the non-codable API.", 
            "title": "Type safety"
        }, 
        {
            "location": "/databases/mysql/basics/#queries", 
            "text": "Queries are any type conforming to the protocol  Query , which requires being convertible to a  String . String  is a Query by default.  You can receive results from Queries in 3 kinds of formats.   Stream  Future  forEach   All examples assume the following model:  struct   User   { \n   var   username :   String \n   var   passwordHash :   String \n   var   age :   Int  }", 
            "title": "Queries"
        }, 
        {
            "location": "/databases/mysql/basics/#streams", 
            "text": "Streams,  as described on this page , are a source of information that calls a single reader's callback. Streams are best used in larger datasets to prevent the query from consuming a large amount of memory. The downside of a stream is that you cannot return all results in a single future. You'll need to stream the results to the other endpoint, too. For HTTP  this is described here.  Querying a database for a stream of results is achieved through the  stream  function and requires specifying the  Decodable  type that the results need to be deserialized into.    // `ModelStream User `  let   usersStream   =   connectionPool . stream ( User . self ,   in :   SELECT * FROM users )   This stream will return all results in the ModelStream's output callback which you can drain. You can register a callback on  usersStream.onClose  that will trigger when the end of the  ModelStream  has been reached.", 
            "title": "Streams"
        }, 
        {
            "location": "/databases/mysql/basics/#futures", 
            "text": "Futures are often easier to use but significantly heavier on your memory and thus performance.  They are thoroughly described here  Querying a database for a future is achieved through the  all  function and requires specifying the  Decodable  type that the results need to be deserialized into.    // Future [User]  let   users   =   connectionPool . all ( User . self ,   in :   SELECT * FROM users )   For partial results ( SELECT username, age FROM ) it is recommended to create a second decodable struct specifically for this query to ensure correctness and type-safety.  struct   UserLoginDetails :   Decodable   { \n   var   username :   String \n   var   age :   Int  }", 
            "title": "Futures"
        }, 
        {
            "location": "/databases/mysql/basics/#foreach", 
            "text": "If you don't need to stream complex results to a third party such as using an HTTP Response you can use  forEach . This is particularly useful for asynchronous actions such as sending a lot of email to the results of a query without depending on the completion/success of one email for the next email.  connectionPool . forEach ( User . self ,   in :   SELECT * FROM users )   {   user   in \n   print ( user . username )  }   forEach  returns a future that you can optionally capture. It will be completed when all users have been processed.  let   completed   =   connectionPool . forEach ( User . self ,   in :   SELECT * FROM users )   {   user   in \n   print ( user . username )  }  completed . then   { \n   print ( All users printed )  }", 
            "title": "ForEach"
        }, 
        {
            "location": "/databases/mysql/basics/#resultless-queries", 
            "text": "Some queries (mostly administrative queries) do not require/return a response. Instead, they only indicate success or error.  You can execute these queries using the  query  command.  connectionPool . query ( DROP TABLE users )   You can handle success or response using the returned future.  connectionPool . query ( DROP TABLE users ). then   { \n   print ( success )  }. catch   { \n   print ( failure )  }", 
            "title": "Resultless queries"
        }, 
        {
            "location": "/redis/", 
            "text": "Redis\n\n\nRedis is a Redis client library that can communicate with a Redis database.\n\n\nWhat is Redis?\n\n\nRedis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).\n\n\nRedis works as a key-value store, but allows querying the keys, unlike most databases.\n\n\nIndex\n\n\n\n\nBasics\n\n\nCustom commands\n\n\nPub/Sub\n\n\nPub/Sub\n\n\n\n\nWith and without Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/redis.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nRedis\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Redis\n to access Redis' APIs.", 
            "title": "Index"
        }, 
        {
            "location": "/redis/#redis", 
            "text": "Redis is a Redis client library that can communicate with a Redis database.", 
            "title": "Redis"
        }, 
        {
            "location": "/redis/#what-is-redis", 
            "text": "Redis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).  Redis works as a key-value store, but allows querying the keys, unlike most databases.", 
            "title": "What is Redis?"
        }, 
        {
            "location": "/redis/#index", 
            "text": "Basics  Custom commands  Pub/Sub  Pub/Sub", 
            "title": "Index"
        }, 
        {
            "location": "/redis/#with-and-without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/redis.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Redis ,   ...   ]) \n     ]  )   Use  import Redis  to access Redis' APIs.", 
            "title": "With and without Vapor"
        }, 
        {
            "location": "/redis/basics/", 
            "text": "Redis basic usage\n\n\nTo interact with Redis, you first need to construct a Redis client.\n\n\nTo connect to Redis you can use a variety of methods. The Redis library primarily supports \nTCP sockets\n.\n\n\nThis requires a hostname, port and \nworker\n. The worker's DispatchQueue will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to \nlocalhost\n, and the port to Redis' default port \n6379\n.\n\n\nlet\n \nclient\n \n=\n \ntry\n \nRedisClient\nTCPClient\n.\nconnect\n(\nworker\n:\n \nworker\n)\n \n// Future\nRedisClient\nTCPClient\n\n\n\n\n\n\nThe \nconnect\n method will return a \nFuture\n containing the TCP based Redis Client.\n\n\nRedis Data Types\n\n\nRedis has 6 data types:\n\n\n\n\nnull\n\n\nInt\n\n\nError\n\n\nArray\n\n\nBasic String (used for command names and basic replies only)\n\n\nBulk String (used for Strings and binary data blobs)\n\n\n\n\nYou can instantiate one from the static functions and variables on \nRedisData\n.\n\n\nlet\n \nnull\n \n=\n \nRedisData\n.\nnull\n\n\n\nlet\n \nhelloWorld\n \n=\n \nRedisData\n.\nbulkString\n(\nHello World\n)\n\n\n\nlet\n \nthree\n \n=\n \nRedisData\n.\ninteger\n(\n3\n)\n\n\n\nlet\n \noneThroughTen\n \n=\n \nRedisData\n.\narray\n([\n\n  \n.\ninteger\n(\n1\n),\n\n  \n.\ninteger\n(\n2\n),\n\n  \n.\ninteger\n(\n3\n),\n\n  \n.\ninteger\n(\n4\n),\n\n  \n.\ninteger\n(\n5\n),\n\n  \n.\ninteger\n(\n6\n),\n\n  \n.\ninteger\n(\n7\n),\n\n  \n.\ninteger\n(\n8\n),\n\n  \n.\ninteger\n(\n9\n),\n\n  \n.\ninteger\n(\n10\n)\n\n\n])\n\n\n\n\n\n\nThe above is the explicit way of defining Redis Types. You can also use literals in most scenarios:\n\n\nlet\n \narray\n \n=\n \nRedisData\n.\narray\n([\n\n  \n[\n\n    \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n\n  \n],\n\n  \nHello World\n,\n\n  \nOne\n,\n\n  \nTwo\n,\n\n  \n.\nnull\n,\n\n  \n.\nnull\n,\n\n  \ntest\n\n\n])\n\n\n\n\n\n\nCRUD using Redis\n\n\nFrom here on it is assumed that your client has been successfully created and is available in the variable \nclient\n as a \nRedisClient\nTCPClient\n.\n\n\nCreating a record\n\n\nCreating a record is done using a \nRedisData\n for a value and a key.\n\n\nclient\n.\nset\n(\nworld\n,\n \nforKey\n:\n \nhello\n)\n\n\n\n\n\n\nThis returns a future that'll indicate successful or unsuccessful insertion.\n\n\nReading a record\n\n\nReading a record is similar, only you'll get a warning if you don't use the returned future.\n\n\nThe \nFuture\nRedisData\n for the key \"hello\" will be \"world\" if you created the record as shown above.\n\n\nlet\n \nfutureRecord\n \n=\n \nclient\n.\ngetData\n(\nforKey\n:\n \nhello\n)\n \n// Future\nRedisData\n\n\n\n\n\n\nDeleting a record\n\n\nDeleting a record is similar but allows querying the keys, too.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\nhello\n])\n\n\n\n\n\n\nWhere the above command will remove the key \"hello\", the next command will delete \nall\n keys from the Redis database.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\n*\n])", 
            "title": "Basics"
        }, 
        {
            "location": "/redis/basics/#redis-basic-usage", 
            "text": "To interact with Redis, you first need to construct a Redis client.  To connect to Redis you can use a variety of methods. The Redis library primarily supports  TCP sockets .  This requires a hostname, port and  worker . The worker's DispatchQueue will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to  localhost , and the port to Redis' default port  6379 .  let   client   =   try   RedisClient TCPClient . connect ( worker :   worker )   // Future RedisClient TCPClient   The  connect  method will return a  Future  containing the TCP based Redis Client.", 
            "title": "Redis basic usage"
        }, 
        {
            "location": "/redis/basics/#redis-data-types", 
            "text": "Redis has 6 data types:   null  Int  Error  Array  Basic String (used for command names and basic replies only)  Bulk String (used for Strings and binary data blobs)   You can instantiate one from the static functions and variables on  RedisData .  let   null   =   RedisData . null  let   helloWorld   =   RedisData . bulkString ( Hello World )  let   three   =   RedisData . integer ( 3 )  let   oneThroughTen   =   RedisData . array ([ \n   . integer ( 1 ), \n   . integer ( 2 ), \n   . integer ( 3 ), \n   . integer ( 4 ), \n   . integer ( 5 ), \n   . integer ( 6 ), \n   . integer ( 7 ), \n   . integer ( 8 ), \n   . integer ( 9 ), \n   . integer ( 10 )  ])   The above is the explicit way of defining Redis Types. You can also use literals in most scenarios:  let   array   =   RedisData . array ([ \n   [ \n     1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,   10 \n   ], \n   Hello World , \n   One , \n   Two , \n   . null , \n   . null , \n   test  ])", 
            "title": "Redis Data Types"
        }, 
        {
            "location": "/redis/basics/#crud-using-redis", 
            "text": "From here on it is assumed that your client has been successfully created and is available in the variable  client  as a  RedisClient TCPClient .", 
            "title": "CRUD using Redis"
        }, 
        {
            "location": "/redis/basics/#creating-a-record", 
            "text": "Creating a record is done using a  RedisData  for a value and a key.  client . set ( world ,   forKey :   hello )   This returns a future that'll indicate successful or unsuccessful insertion.", 
            "title": "Creating a record"
        }, 
        {
            "location": "/redis/basics/#reading-a-record", 
            "text": "Reading a record is similar, only you'll get a warning if you don't use the returned future.  The  Future RedisData  for the key \"hello\" will be \"world\" if you created the record as shown above.  let   futureRecord   =   client . getData ( forKey :   hello )   // Future RedisData", 
            "title": "Reading a record"
        }, 
        {
            "location": "/redis/basics/#deleting-a-record", 
            "text": "Deleting a record is similar but allows querying the keys, too.  client . delete ( keys :   [ hello ])   Where the above command will remove the key \"hello\", the next command will delete  all  keys from the Redis database.  client . delete ( keys :   [ * ])", 
            "title": "Deleting a record"
        }, 
        {
            "location": "/redis/custom-commands/", 
            "text": "Custom commands\n\n\nMany commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.\n\n\n(Almost) all functions listed here\n work out of the box using custom commands.\n\n\nUsage\n\n\nThe Redis client has a \nrun\n function that allows you to run these commands.\n\n\nThe following code demonstrates a \"custom\" implementation for \nGET\n.\n\n\nlet\n \nfuture\n \n=\n \nclient\n.\nrun\n(\ncommand\n:\n \nGET\n,\n \narguments\n:\n \n[\nmy-key\n])\n \n// Future\nRedisData\n\n\n\n\n\n\nThis future will contain the result as specified in the article on the redis command page or an error.\n\n\nThe future can be used as described in the \nAsync API\n.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#custom-commands", 
            "text": "Many commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.  (Almost) all functions listed here  work out of the box using custom commands.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#usage", 
            "text": "The Redis client has a  run  function that allows you to run these commands.  The following code demonstrates a \"custom\" implementation for  GET .  let   future   =   client . run ( command :   GET ,   arguments :   [ my-key ])   // Future RedisData   This future will contain the result as specified in the article on the redis command page or an error.  The future can be used as described in the  Async API .", 
            "title": "Usage"
        }, 
        {
            "location": "/redis/pub-sub/", 
            "text": "Publish \n Subscribe\n\n\nRedis' Publish and Subscribe model is really useful for notifications.\n\n\nUse cases\n\n\nPub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.\n\n\nA channel consists of a name and group of listeners. Think of it as being \n[String: [Listener]]\n.\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.\n\n\nChannels must be a string. For chat groups, for example, you could use the database identifier.\n\n\nPublishing\n\n\nYou cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:\n\n\n// Any redis data\n\n\nlet\n \nnotification\n:\n \nRedisData\n \n=\n \nMy-Notification\n\n\n\nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n\n\n\n\n\n\nIf you want access to the listener count:\n\n\nlet\n \nnotifiedCount\n \n=\n \nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n \n// Future\nInt\n\n\n\n\n\n\nSubscribing\n\n\nTo subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.\n\n\nA single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a \nSubscriptionStream\n.\n\n\nlet\n \nnotifications\n \n=\n \nclient\n.\nsubscribe\n(\nto\n:\n \n[\nsome-notification-channel\n,\n \nother-notification-channel\n])\n\n\n\n\n\n\nIf you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.\n\n\nThis stream will receive messages asynchronously from the point of \ndraining\n. This works like \nany other async stream\n\n\nNotifications consist of the channel and payload.\n\n\nnotifications\n.\ndrain\n \n{\n \nnotification\n \nin\n\n  \nprint\n(\nnotification\n.\nchannel\n)\n\n\n  \nlet\n \npayload\n \n=\n \nnotification\n.\npayload\n\n\n  \n// \nTODO:\n Process the payload\n\n\n}", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#publish-subscribe", 
            "text": "Redis' Publish and Subscribe model is really useful for notifications.", 
            "title": "Publish &amp; Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#use-cases", 
            "text": "Pub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.  A channel consists of a name and group of listeners. Think of it as being  [String: [Listener]] .\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.  Channels must be a string. For chat groups, for example, you could use the database identifier.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pub-sub/#publishing", 
            "text": "You cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:  // Any redis data  let   notification :   RedisData   =   My-Notification  client . publish ( notification ,   to :   my-channel )   If you want access to the listener count:  let   notifiedCount   =   client . publish ( notification ,   to :   my-channel )   // Future Int", 
            "title": "Publishing"
        }, 
        {
            "location": "/redis/pub-sub/#subscribing", 
            "text": "To subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.  A single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a  SubscriptionStream .  let   notifications   =   client . subscribe ( to :   [ some-notification-channel ,   other-notification-channel ])   If you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.  This stream will receive messages asynchronously from the point of  draining . This works like  any other async stream  Notifications consist of the channel and payload.  notifications . drain   {   notification   in \n   print ( notification . channel ) \n\n   let   payload   =   notification . payload \n\n   //  TODO:  Process the payload  }", 
            "title": "Subscribing"
        }, 
        {
            "location": "/redis/pipeline/", 
            "text": "Pipelining\n\n\nPipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle. \n\n\nUse cases\n\n\nSometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.\n\n\nEnqueuing Commands\n\n\n \nlet\n \npipeline\n \n=\n \nconnection\n.\nmakePipeline\n()\n\n \nlet\n \nresult\n \n=\n \ntry\n \npipeline\n\n         \n.\nenqueue\n(\ncommand\n:\n \nSET\n,\n \narguments\n:\n \n[\nKEY\n,\n \nVALUE\n])\n\n         \n.\nenqueue\n(\ncommand\n:\n \nINCR\n,\n \narguments\n:\n \n[\nCOUNT\n])\n\n         \n.\nexecute\n()\n \n// Future\n[RedisData]\n\n\n\n\n\n\nNote: Commands will not be executed until execute is called.", 
            "title": "Pipeline"
        }, 
        {
            "location": "/redis/pipeline/#pipelining", 
            "text": "Pipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle.", 
            "title": "Pipelining"
        }, 
        {
            "location": "/redis/pipeline/#use-cases", 
            "text": "Sometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pipeline/#enqueuing-commands", 
            "text": "let   pipeline   =   connection . makePipeline () \n  let   result   =   try   pipeline \n          . enqueue ( command :   SET ,   arguments :   [ KEY ,   VALUE ]) \n          . enqueue ( command :   INCR ,   arguments :   [ COUNT ]) \n          . execute ()   // Future [RedisData]   Note: Commands will not be executed until execute is called.", 
            "title": "Enqueuing Commands"
        }, 
        {
            "location": "/websocket/websocket/", 
            "text": "WebSocket\n\n\nWebSockets are a type of connection that can be instantiated by upgrading an existing HTTP/1 connection. They're used to dispatch notifications and communicate real-time binary and textual Data.\n\n\nUsing websockets\n\n\nWebSockets are interacted with using \nbinary streams\n or \ntext streams\n.\n\n\nErrors\n\n\nAny error in a WebSocket will close the connection.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/websocket/websocket/#websocket", 
            "text": "WebSockets are a type of connection that can be instantiated by upgrading an existing HTTP/1 connection. They're used to dispatch notifications and communicate real-time binary and textual Data.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/websocket/websocket/#using-websockets", 
            "text": "WebSockets are interacted with using  binary streams  or  text streams .", 
            "title": "Using websockets"
        }, 
        {
            "location": "/websocket/websocket/#errors", 
            "text": "Any error in a WebSocket will close the connection.", 
            "title": "Errors"
        }, 
        {
            "location": "/websocket/binary-stream/", 
            "text": "Binary Streams\n\n\nWebSockets have separate \ntext\n and binary data flows.\n\n\nSending binary input to a WebSocket sends it to the remote. Listening for binary on a WebSocket receives binary (and binary continuation) data from clients.\n\n\nSending binary data\n\n\nSending a \nData\n or \nByteBuffer\n using a WebSocket sends it to the remote.\n\n\nwebSocket\n.\nsend\n(\nbyteBuffer\n)\n\n\nwebSocket\n.\nsend\n(\ndata\n)\n\n\n\n\n\n\nReceiving binary data\n\n\nBinary data can be read as a \nByteBuffer\n using the following function. Only one closure can read at a time.\n\n\nwebSocket\n.\nonBinary\n \n{\n \nbyteBuffer\n \nin\n\n  \n// use the `ByteBuffer`\n\n\n}\n\n\n\n\n\n\nBinary data can also, instead, be used as Foundation's \nData\n. This is less efficient than \nByteBuffer\n but often easier to use.\n\n\nwebSocket\n.\nonData\n \n{\n \ndata\n \nin\n\n  \n// use the `Data`\n\n\n}\n\n\n\n\n\n\nYou can only use one of the two listeners at a time.", 
            "title": "Binary"
        }, 
        {
            "location": "/websocket/binary-stream/#binary-streams", 
            "text": "WebSockets have separate  text  and binary data flows.  Sending binary input to a WebSocket sends it to the remote. Listening for binary on a WebSocket receives binary (and binary continuation) data from clients.", 
            "title": "Binary Streams"
        }, 
        {
            "location": "/websocket/binary-stream/#sending-binary-data", 
            "text": "Sending a  Data  or  ByteBuffer  using a WebSocket sends it to the remote.  webSocket . send ( byteBuffer )  webSocket . send ( data )", 
            "title": "Sending binary data"
        }, 
        {
            "location": "/websocket/binary-stream/#receiving-binary-data", 
            "text": "Binary data can be read as a  ByteBuffer  using the following function. Only one closure can read at a time.  webSocket . onBinary   {   byteBuffer   in \n   // use the `ByteBuffer`  }   Binary data can also, instead, be used as Foundation's  Data . This is less efficient than  ByteBuffer  but often easier to use.  webSocket . onData   {   data   in \n   // use the `Data`  }   You can only use one of the two listeners at a time.", 
            "title": "Receiving binary data"
        }, 
        {
            "location": "/websocket/text-stream/", 
            "text": "Text Streams\n\n\nWebSockets have separate text and \nbinary\n data flows.\n\n\nSending text input to a WebSocket sends it to the remote. Listening for text on a WebSocket receives text data from clients.\n\n\nSending strings\n\n\nSending a \nString\n using a WebSocket sends it to the remote.\n\n\nwebSocket\n.\nsend\n(\nstring\n)\n\n\n\n\n\n\nReceiving strings\n\n\nString data can be read using the following function. Only one closure can read at a time.\n\n\nwebSocket\n.\nonText\n \n{\n \ntext\n \nin\n\n  \n// use the `String`\n\n\n}", 
            "title": "Text"
        }, 
        {
            "location": "/websocket/text-stream/#text-streams", 
            "text": "WebSockets have separate text and  binary  data flows.  Sending text input to a WebSocket sends it to the remote. Listening for text on a WebSocket receives text data from clients.", 
            "title": "Text Streams"
        }, 
        {
            "location": "/websocket/text-stream/#sending-strings", 
            "text": "Sending a  String  using a WebSocket sends it to the remote.  webSocket . send ( string )", 
            "title": "Sending strings"
        }, 
        {
            "location": "/websocket/text-stream/#receiving-strings", 
            "text": "String data can be read using the following function. Only one closure can read at a time.  webSocket . onText   {   text   in \n   // use the `String`  }", 
            "title": "Receiving strings"
        }, 
        {
            "location": "/websocket/client/", 
            "text": "WebSocket Client\n\n\nWebSocket clients work the same on the client side as the \nserver side\n.\n\n\nConnecting a WebSocket client\n\n\nWebSockets require an \nURI\n to connect to and a \nWorker\n to run on.\n\n\nlet\n \nworker\n:\n \nWorker\n \n=\n \n...\n\n\n\nlet\n \nfutureWebSocket\n:\n \nFuture\nWebSocket\n \n=\n \ntry\n \nWebSocket\n.\nconnect\n(\nto\n:\n \nws://localhost/path\n,\n \nqueue\n:\n \nqueue\n)\n\n\n\n\n\n\nUsing websockets\n\n\nWebSockets are interacted with using \nbinary streams\n or \ntext streams\n.\n\n\nAll other information about websockets \nis defined here.", 
            "title": "Client"
        }, 
        {
            "location": "/websocket/client/#websocket-client", 
            "text": "WebSocket clients work the same on the client side as the  server side .", 
            "title": "WebSocket Client"
        }, 
        {
            "location": "/websocket/client/#connecting-a-websocket-client", 
            "text": "WebSockets require an  URI  to connect to and a  Worker  to run on.  let   worker :   Worker   =   ...  let   futureWebSocket :   Future WebSocket   =   try   WebSocket . connect ( to :   ws://localhost/path ,   queue :   queue )", 
            "title": "Connecting a WebSocket client"
        }, 
        {
            "location": "/websocket/client/#using-websockets", 
            "text": "WebSockets are interacted with using  binary streams  or  text streams .  All other information about websockets  is defined here.", 
            "title": "Using websockets"
        }, 
        {
            "location": "/websocket/server/", 
            "text": "TODO", 
            "title": "Server"
        }, 
        {
            "location": "/websocket/server/#todo", 
            "text": "", 
            "title": "TODO"
        }, 
        {
            "location": "/websocket/upgrade/", 
            "text": "WebSocket Upgrading\n\n\nDetermining an upgrade\n\n\nUpgrading the connection", 
            "title": "Server Upgrades"
        }, 
        {
            "location": "/websocket/upgrade/#websocket-upgrading", 
            "text": "", 
            "title": "WebSocket Upgrading"
        }, 
        {
            "location": "/websocket/upgrade/#determining-an-upgrade", 
            "text": "", 
            "title": "Determining an upgrade"
        }, 
        {
            "location": "/websocket/upgrade/#upgrading-the-connection", 
            "text": "", 
            "title": "Upgrading the connection"
        }, 
        {
            "location": "/jwt/jws/", 
            "text": "JWS (JSON Web Signature) tokens\n\n\nJSON Web Signatures are a Base64 encoded token with a signature for verification.\n\n\nThis means signatures can be read by the client and \nmust not\n contain sensitive data such as passwords.\n\n\nIt can be used as an authentication token or \"proof\" by the client.\n\n\nIt does not need to be stored on the server and can be verified by any server that knows the key used for signing.\n\n\nCreating a token\n\n\nCreating a token is as simple as creating a Codable struct.\n\n\nstruct\n \nAuthorizationToken\n \n:\n \nCodable\n \n{\n\n  \nlet\n \nauthenticatedUsername\n:\n \nString\n\n\n}\n\n\n\n\n\n\nSending a signed token with the client\n\n\nTo send a token to the client, you need to sign it. Signing is done using a \"secret\". Secrets are a static key that stays the same across server reboots and is usually put inside a configuration file.\n\n\nSecrets \nshould\n be randomly generated. Longer secrets and less predictable are better, there is no limit.\n\n\nOnce a secret is available in the application you can sign your tokens.\n\n\nTo sign your token, you need to select an algorithm. We support \nhs256\n, \nhs384\n and \nhs512\n.\n\n\nlet\n \nheader\n \n=\n \nJWT\n.\nHeader\n.\nhs512\n()\n\n\n\n\n\n\nFor this example, the following token/payload is used:\n\n\nlet\n \ntoken\n \n=\n \nAuthorizationToken\n(\nauthenticatedUsername\n:\n \nExample Username\n)\n\n\n\n\n\n\nThen, create a signature.\n\n\nlet\n \nsecret\n:\n \nData\n \n=\n \n...\n \n// your secret\n\n\n\nlet\n \njws\n \n=\n \nJSONWebSignature\n(\nheaders\n:\n \n[\nheader\n],\n \npayload\n:\n \ntoken\n,\n \nsecret\n:\n \nsecret\n)\n\n\n\n\n\n\nSecrets are expected to be a \nFoundation.Data\n. If your secret is a \nString\n, convert it using \nData(stringSecret.utf8)\n.\n\n\nTo receive the signature as a String (for in a Cookie or JSON response) you can use \nsignedString\n.\n\n\nlet\n \nencodedSignature\n:\n \nString\n \n=\n \ntry\n \njws\n.\nsignedString\n()\n\n\n\n\n\n\nIf you want binary data instead, use \nsign\n:\n\n\nlet\n \nencodedSignature\n:\n \nData\n \n=\n \ntry\n \njws\n.\nsign\n()\n\n\n\n\n\n\nDecoding a token\n\n\nWhen the client interacts with your website again, they'll have a token this time. This token needs to be decoded and verified first.\n\n\nlet\n \nsignature\n:\n \ntry\n \nJSONWebSignature\nAuthorizationToken\n(\nfrom\n:\n \nencodedSignature\n,\n \nverifyingWith\n:\n \nsecret\n)\n\n\n\n\n\n\nThe \nsignature\n in this example is a \nData\n or \nString\n containing the encoded signature.\n\n\nThe secret is the same secret we used in the above example for signing.\n\n\nIf the message has been tampered with, the token will not be initialized and an error will be thrown instead.\n\n\nTo extract the \nAuthorizationToken\n, you access the \ntoken.payload\n.\n\n\nlet\n \ntoken\n:\n \nAuthorizationToken\n \n=\n \nsignature\n.\npayload\n\n\n\nprint\n(\ntoken\n.\nusername\n)\n \n// prints \nExample Username", 
            "title": "Signed Tokens"
        }, 
        {
            "location": "/jwt/jws/#jws-json-web-signature-tokens", 
            "text": "JSON Web Signatures are a Base64 encoded token with a signature for verification.  This means signatures can be read by the client and  must not  contain sensitive data such as passwords.  It can be used as an authentication token or \"proof\" by the client.  It does not need to be stored on the server and can be verified by any server that knows the key used for signing.", 
            "title": "JWS (JSON Web Signature) tokens"
        }, 
        {
            "location": "/jwt/jws/#creating-a-token", 
            "text": "Creating a token is as simple as creating a Codable struct.  struct   AuthorizationToken   :   Codable   { \n   let   authenticatedUsername :   String  }", 
            "title": "Creating a token"
        }, 
        {
            "location": "/jwt/jws/#sending-a-signed-token-with-the-client", 
            "text": "To send a token to the client, you need to sign it. Signing is done using a \"secret\". Secrets are a static key that stays the same across server reboots and is usually put inside a configuration file.  Secrets  should  be randomly generated. Longer secrets and less predictable are better, there is no limit.  Once a secret is available in the application you can sign your tokens.  To sign your token, you need to select an algorithm. We support  hs256 ,  hs384  and  hs512 .  let   header   =   JWT . Header . hs512 ()   For this example, the following token/payload is used:  let   token   =   AuthorizationToken ( authenticatedUsername :   Example Username )   Then, create a signature.  let   secret :   Data   =   ...   // your secret  let   jws   =   JSONWebSignature ( headers :   [ header ],   payload :   token ,   secret :   secret )   Secrets are expected to be a  Foundation.Data . If your secret is a  String , convert it using  Data(stringSecret.utf8) .  To receive the signature as a String (for in a Cookie or JSON response) you can use  signedString .  let   encodedSignature :   String   =   try   jws . signedString ()   If you want binary data instead, use  sign :  let   encodedSignature :   Data   =   try   jws . sign ()", 
            "title": "Sending a signed token with the client"
        }, 
        {
            "location": "/jwt/jws/#decoding-a-token", 
            "text": "When the client interacts with your website again, they'll have a token this time. This token needs to be decoded and verified first.  let   signature :   try   JSONWebSignature AuthorizationToken ( from :   encodedSignature ,   verifyingWith :   secret )   The  signature  in this example is a  Data  or  String  containing the encoded signature.  The secret is the same secret we used in the above example for signing.  If the message has been tampered with, the token will not be initialized and an error will be thrown instead.  To extract the  AuthorizationToken , you access the  token.payload .  let   token :   AuthorizationToken   =   signature . payload  print ( token . username )   // prints  Example Username", 
            "title": "Decoding a token"
        }, 
        {
            "location": "/crypto/", 
            "text": "Using Crypto\n\n\nCrypto is a library containing all common APIs related to cryptography and security.\n\n\nThis project does \nnot\n support TLS. For that, please see \nthe TLS package\n.\n\n\nIndex\n\n\n\n\nPassword hashing and verification\n\n\nMessage authentication\n\n\nBase64 (also Streaming)\n\n\nHashes (also Streaming)\n\n\nRandom\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nCrypto\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/crypto.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \nx.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nCrypto\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Crypto\n to access Crypto's APIs.", 
            "title": "Index"
        }, 
        {
            "location": "/crypto/#using-crypto", 
            "text": "Crypto is a library containing all common APIs related to cryptography and security.  This project does  not  support TLS. For that, please see  the TLS package .", 
            "title": "Using Crypto"
        }, 
        {
            "location": "/crypto/#index", 
            "text": "Password hashing and verification  Message authentication  Base64 (also Streaming)  Hashes (also Streaming)  Random", 
            "title": "Index"
        }, 
        {
            "location": "/crypto/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Crypto", 
            "title": "With Vapor"
        }, 
        {
            "location": "/crypto/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/crypto.git ,   . upToNextMajor ( from :   x.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Crypto ,   ...   ]) \n     ]  )   Use  import Crypto  to access Crypto's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/crypto/base64/", 
            "text": "Encoding\n\n\nBase64Encoder\n is used to encode Base64 data. It works either as a stream or as a bulk decoder.\n\n\nBulk Encoding\n\n\nBase64 can be bulk-encoded using a static method \nencode\n. This throws an error if the base64 is invalid.\n\n\nYou can encode \nString\n, \nData\n or \nByteBuffer\n input.\n\n\nlet\n \nencodedData\n:\n \nData\n \n=\n \nBase64Encoder\n.\nencode\n(\ninput\n)\n\n\n\n\n\n\nStream Encoding\n\n\nTo use the Base64 streaming encoder, you first need to initialize the \nBase64Encoder\n.\n\n\nlet\n \nencoder\n \n=\n \nBase64Encoder\n()\n\n\n\n\n\n\nThe input of the \nBase64Encoder\n is the raw data. The output is Base64 encoded data. The final Base64-padding will be applied only when the input stream closes.\n\n\nDecoding\n\n\nBase64Decoder\n is used to decode Base64 data. It works either as a stream or as a bulk decoder.\n\n\nBulk Decoding\n\n\nBase64 can be bulk-decoded using a static method \ndecode\n. This throws an error if the base64 is invalid.\n\n\nYou can decode \nString\n, \nData\n or \nByteBuffer\n input.\n\n\nlet\n \ndecodedData\n:\n \nData\n \n=\n \ntry\n \nBase64Decoder\n.\ndecode\n(\ninput\n)\n\n\n\n\n\n\nStream Decoding\n\n\nTo use the Base64 streaming decoder, you first need to initialize the \nBase64Decoder\n.\n\n\nlet\n \nencoder\n \n=\n \nBase64Decoder\n()\n\n\n\n\n\n\nThe input of the \nBase64Decoder\n is the Base64 encoded data. The output is raw data.\n\n\nTips\n\n\nTransforming binary streams\n\n\nBoth \nBase64Encoder\n and \nBase64Decoder\n have a static \ntransform\n function that transforms an existing stream of data using the en/decoder.\n\n\nlet\n \nbase64EncodedStream\n \n=\n \nBase64Encoder\n.\ntransform\n(\nbinaryStream\n)\n\n\nlet\n \nnewBinaryStream\n \n=\n \nBase64Decoder\n.\ntransform\n(\nbase64EncodedStream\n)\n\n\n\n\n\n\nOptimization\n\n\nBoth \nBase64Encoder\n as well as \nBase64Decoder\n accept the \ndecodedCapacity\n. This is the expected amount of decoded bytes you expect to input or receive.\n\n\nIf you expect to receive (a maximum of) \n100_000\n bytes of input to encode per event on the stream, you should make that the \ndecodedCapacity\n. By default it's set to \nUInt16.max\n, which is sensible for TCP sockets.", 
            "title": "Base64"
        }, 
        {
            "location": "/crypto/base64/#encoding", 
            "text": "Base64Encoder  is used to encode Base64 data. It works either as a stream or as a bulk decoder.", 
            "title": "Encoding"
        }, 
        {
            "location": "/crypto/base64/#bulk-encoding", 
            "text": "Base64 can be bulk-encoded using a static method  encode . This throws an error if the base64 is invalid.  You can encode  String ,  Data  or  ByteBuffer  input.  let   encodedData :   Data   =   Base64Encoder . encode ( input )", 
            "title": "Bulk Encoding"
        }, 
        {
            "location": "/crypto/base64/#stream-encoding", 
            "text": "To use the Base64 streaming encoder, you first need to initialize the  Base64Encoder .  let   encoder   =   Base64Encoder ()   The input of the  Base64Encoder  is the raw data. The output is Base64 encoded data. The final Base64-padding will be applied only when the input stream closes.", 
            "title": "Stream Encoding"
        }, 
        {
            "location": "/crypto/base64/#decoding", 
            "text": "Base64Decoder  is used to decode Base64 data. It works either as a stream or as a bulk decoder.", 
            "title": "Decoding"
        }, 
        {
            "location": "/crypto/base64/#bulk-decoding", 
            "text": "Base64 can be bulk-decoded using a static method  decode . This throws an error if the base64 is invalid.  You can decode  String ,  Data  or  ByteBuffer  input.  let   decodedData :   Data   =   try   Base64Decoder . decode ( input )", 
            "title": "Bulk Decoding"
        }, 
        {
            "location": "/crypto/base64/#stream-decoding", 
            "text": "To use the Base64 streaming decoder, you first need to initialize the  Base64Decoder .  let   encoder   =   Base64Decoder ()   The input of the  Base64Decoder  is the Base64 encoded data. The output is raw data.", 
            "title": "Stream Decoding"
        }, 
        {
            "location": "/crypto/base64/#tips", 
            "text": "", 
            "title": "Tips"
        }, 
        {
            "location": "/crypto/base64/#transforming-binary-streams", 
            "text": "Both  Base64Encoder  and  Base64Decoder  have a static  transform  function that transforms an existing stream of data using the en/decoder.  let   base64EncodedStream   =   Base64Encoder . transform ( binaryStream )  let   newBinaryStream   =   Base64Decoder . transform ( base64EncodedStream )", 
            "title": "Transforming binary streams"
        }, 
        {
            "location": "/crypto/base64/#optimization", 
            "text": "Both  Base64Encoder  as well as  Base64Decoder  accept the  decodedCapacity . This is the expected amount of decoded bytes you expect to input or receive.  If you expect to receive (a maximum of)  100_000  bytes of input to encode per event on the stream, you should make that the  decodedCapacity . By default it's set to  UInt16.max , which is sensible for TCP sockets.", 
            "title": "Optimization"
        }, 
        {
            "location": "/crypto/hash/", 
            "text": "Hash\n\n\nHashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.\n\n\nAvailable hashes\n\n\nCrypto currently supports a few hashes.\n\n\n\n\nMD5\n\n\nSHA1\n\n\nSHA2 (all variants)\n\n\n\n\nMD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.\n\n\nEvery Hash type has a set of helpers that you can use.\n\n\nHashing blobs of data\n\n\nEvery \nHash\n has a static method called \nhash\n that can be used for hashing the entire contents of \nFoundation.Data\n, \nByteBuffer\n or \nString\n.\n\n\nThe result is \nData\n containing the resulting hash. The hash's length is according to spec and defined in the static variable \ndigestSize\n.\n\n\n// MD5 with `Data`\n\n\nlet\n \nfileData\n \n=\n \nData\n()\n\n\nlet\n \nfileMD5\n \n=\n \nMD5\n.\nhash\n(\nfileData\n)\n\n\n\n// SHA1 with `ByteBuffer`\n\n\nlet\n \nfileBuffer\n:\n \nByteBuffer\n \n=\n \n...\n\n\nlet\n \nfileSHA1\n \n=\n \nSHA1\n.\nhash\n(\nfileBuffer\n)\n\n\n\n// SHA2 variants with String\n\n\nlet\n \nstaticUnsafeToken\n:\n \nString\n \n=\n \nrsadd14ndmasidfm12i4j\n\n\n\nlet\n \ntokenHashSHA224\n \n=\n \nSHA224\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA256\n \n=\n \nSHA256\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA384\n \n=\n \nSHA384\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA512\n \n=\n \nSHA512\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\n\n\n\n\nIncremental hashes (manual)\n\n\nTo incrementally process hashes you can create an instance of the Hash. This will set up a context.\n\n\nAll hash context initializers are empty:\n\n\n// Create an MD5 context\n\n\nlet\n \nmd5Context\n \n=\n \nMD5\n()\n\n\n\n\n\n\nTo process a single chunk of data, you can call the \nupdate\n function on a context using any \nSequence\n of \nUInt8\n. That means \nArray\n, \nData\n and \nByteBuffer\n work alongside any other sequence of bytes.\n\n\nmd5Context\n.\nupdate\n(\ndata\n)\n\n\n\n\n\n\nThe data data need not be a specific length. Any length works.\n\n\nWhen you need the result, you can call \nmd5Context.finalize()\n. This will finish calculating the hash by appending the standard \n1\n bit, padding and message bitlength.\n\n\nYou can optionally provide a last set of data to \nfinalize()\n.\n\n\nAfter calling \nfinalize()\n, do not update the hash if you want correct results.\n\n\nFetching the results\n\n\nThe context can then be accessed to extract the resulting Hash.\n\n\nlet\n \nhash\n:\n \nData\n \n=\n \nmd5Context\n.\nhash\n\n\n\n\n\n\nStreaming hashes (Async)\n\n\nSometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use \nStreamHasher\n.\n\n\nFirst, create a new generic \nStreamHasher\nHash\n where \nHash\n is the hash you want to use. In this case, SHA512.\n\n\nlet\n \nstreamHasher\n \n=\n \nStreamHasher\nSHA512\n()\n\n\n\n\n\n\nThis stream works like any \ninputStream\n by consuming the incoming data and passing the buffers to the hash context.\n\n\nFor example, draining a TCP socket.\n\n\nlet\n \nsocket\n:\n \nTCP\n.\nSocket\n \n=\n \n...\n\n\n\nsocket\n.\ndrain\n(\ninto\n:\n \nstreamHasher\n)\n\n\n\n\n\n\nThis will incrementally update the hash using the provided TCP socket's data.\n\n\nWhen the hash has been completely accumulated, you can \ncomplete\n the hash.\n\n\nlet\n \nhash\n:\n \nData\n \n=\n \nstreamHasher\n.\ncomplete\n()\n\n\n\n\n\n\nThis will reset the hash's context to the default configuration, ready to start over.\n\n\nUsing StreamHasher as a transparent component\n\n\nStreamHasher is only an \nInputStream\n, meaning it doesn't output anything. In some scenarios, like uploading a file, you want both the unaltered file data in addition to the hash. One solution is to split the stream. But that adds unnecessary complexity.\n\n\nPassthroughByteStreamHasher\n is a \nByteStreamHasher\n that's also an \nOutputStream\n. The output it emits is identical to the \nPassthroughByteStreamHasher\n's input.\n\n\nPassthroughByteStreamHasher\n functions exactly like \nByteStreamHasher", 
            "title": "Hashes"
        }, 
        {
            "location": "/crypto/hash/#hash", 
            "text": "Hashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.", 
            "title": "Hash"
        }, 
        {
            "location": "/crypto/hash/#available-hashes", 
            "text": "Crypto currently supports a few hashes.   MD5  SHA1  SHA2 (all variants)   MD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.  Every Hash type has a set of helpers that you can use.", 
            "title": "Available hashes"
        }, 
        {
            "location": "/crypto/hash/#hashing-blobs-of-data", 
            "text": "Every  Hash  has a static method called  hash  that can be used for hashing the entire contents of  Foundation.Data ,  ByteBuffer  or  String .  The result is  Data  containing the resulting hash. The hash's length is according to spec and defined in the static variable  digestSize .  // MD5 with `Data`  let   fileData   =   Data ()  let   fileMD5   =   MD5 . hash ( fileData )  // SHA1 with `ByteBuffer`  let   fileBuffer :   ByteBuffer   =   ...  let   fileSHA1   =   SHA1 . hash ( fileBuffer )  // SHA2 variants with String  let   staticUnsafeToken :   String   =   rsadd14ndmasidfm12i4j  let   tokenHashSHA224   =   SHA224 . hash ( staticUnsafeToken )  let   tokenHashSHA256   =   SHA256 . hash ( staticUnsafeToken )  let   tokenHashSHA384   =   SHA384 . hash ( staticUnsafeToken )  let   tokenHashSHA512   =   SHA512 . hash ( staticUnsafeToken )", 
            "title": "Hashing blobs of data"
        }, 
        {
            "location": "/crypto/hash/#incremental-hashes-manual", 
            "text": "To incrementally process hashes you can create an instance of the Hash. This will set up a context.  All hash context initializers are empty:  // Create an MD5 context  let   md5Context   =   MD5 ()   To process a single chunk of data, you can call the  update  function on a context using any  Sequence  of  UInt8 . That means  Array ,  Data  and  ByteBuffer  work alongside any other sequence of bytes.  md5Context . update ( data )   The data data need not be a specific length. Any length works.  When you need the result, you can call  md5Context.finalize() . This will finish calculating the hash by appending the standard  1  bit, padding and message bitlength.  You can optionally provide a last set of data to  finalize() .  After calling  finalize() , do not update the hash if you want correct results.", 
            "title": "Incremental hashes (manual)"
        }, 
        {
            "location": "/crypto/hash/#fetching-the-results", 
            "text": "The context can then be accessed to extract the resulting Hash.  let   hash :   Data   =   md5Context . hash", 
            "title": "Fetching the results"
        }, 
        {
            "location": "/crypto/hash/#streaming-hashes-async", 
            "text": "Sometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use  StreamHasher .  First, create a new generic  StreamHasher Hash  where  Hash  is the hash you want to use. In this case, SHA512.  let   streamHasher   =   StreamHasher SHA512 ()   This stream works like any  inputStream  by consuming the incoming data and passing the buffers to the hash context.  For example, draining a TCP socket.  let   socket :   TCP . Socket   =   ...  socket . drain ( into :   streamHasher )   This will incrementally update the hash using the provided TCP socket's data.  When the hash has been completely accumulated, you can  complete  the hash.  let   hash :   Data   =   streamHasher . complete ()   This will reset the hash's context to the default configuration, ready to start over.", 
            "title": "Streaming hashes (Async)"
        }, 
        {
            "location": "/crypto/hash/#using-streamhasher-as-a-transparent-component", 
            "text": "StreamHasher is only an  InputStream , meaning it doesn't output anything. In some scenarios, like uploading a file, you want both the unaltered file data in addition to the hash. One solution is to split the stream. But that adds unnecessary complexity.  PassthroughByteStreamHasher  is a  ByteStreamHasher  that's also an  OutputStream . The output it emits is identical to the  PassthroughByteStreamHasher 's input.  PassthroughByteStreamHasher  functions exactly like  ByteStreamHasher", 
            "title": "Using StreamHasher as a transparent component"
        }, 
        {
            "location": "/crypto/mac/", 
            "text": "Message authentication\n\n\nMessage authentication is used for verifying message authenticity and validity.\n\n\nCommon use cases are JSON Web Tokens.\n\n\nFor message authentication, Vapor only supports HMAC.\n\n\nUsing HMAC\n\n\nTo use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.\n\n\nlet\n \nhash\n \n=\n \nHMAC\nSHA224\n.\nauthenticate\n(\nmessage\n,\n \nwithKey\n:\n \nauthenticationKey\n)", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#message-authentication", 
            "text": "Message authentication is used for verifying message authenticity and validity.  Common use cases are JSON Web Tokens.  For message authentication, Vapor only supports HMAC.", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#using-hmac", 
            "text": "To use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.  let   hash   =   HMAC SHA224 . authenticate ( message ,   withKey :   authenticationKey )", 
            "title": "Using HMAC"
        }, 
        {
            "location": "/crypto/passwords/", 
            "text": "Password hashing\n\n\nPassword management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.\n\n\nFor password hashing Vapor supports PBKDF2 and BCrypt.\n\n\nWe recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.\n\n\nBCrypt\n\n\nBCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.\n\n\nDeriving a key\n\n\nUnlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.\n\n\nThe output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.\n\n\nlet\n \nresult\n:\n \nData\n \n=\n \ntry\n \nBCrypt\n.\nmake\n(\nmessage\n:\n \nMyPassword\n)\n\n\n\nguard\n \ntry\n \nBCrypt\n.\nverify\n(\nmessage\n:\n \nMyPassword\n,\n \nmatches\n:\n \nresult\n)\n \nelse\n \n{\n\n    \nfatalError\n(\nThis never triggers, since the verification process will always be successful for the same password and conditions\n)\n\n\n}\n\n\n\n\n\n\nThe default cost factor is \n12\n, based on the official recommendations.\n\n\nStoring the derived key as a String\n\n\nBCrypt always outputs valid ASCII/UTF-8 for the resulting hash.\n\n\nThis means you can convert the output \nData\n to a \nString\n as such:\n\n\nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nresult\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n    \n// This must never trigger\n\n\n}\n\n\n\n\n\n\nPBKDF2\n\n\nPBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.\n\n\nPBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.\n\n\nFor PBKDF2 you also select the Hash using generics.\n\n\nDeriving a key\n\n\nIn the following example:\n\n\n\n\npassword\n is either a \nString\n or \nData\n\n\nThe \nsalt\n is \nData\n\n\nIterations is defaulted to \n10_000\n iterations\n\n\nThe keySize is equivalent to 1 hash's length.\n\n\n\n\n// Generate a random salt\n\n\nlet\n \nsalt\n:\n \nData\n \n=\n \nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n)\n\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n)\n\n\n\n\n\n\nYou can optionally configure PBKDF2 to use a different iteration count and output keysize.\n\n\n// Iterates 20\n000 times and outputs 100 bytes\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n,\n \niterating\n:\n \n20_000\n,\n \nderivedKeyLength\n:\n \n100\n)\n\n\n\n\n\n\nStoring the results\n\n\nWhen you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#password-hashing", 
            "text": "Password management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.  For password hashing Vapor supports PBKDF2 and BCrypt.  We recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#bcrypt", 
            "text": "BCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.", 
            "title": "BCrypt"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key", 
            "text": "Unlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.  The output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.  let   result :   Data   =   try   BCrypt . make ( message :   MyPassword )  guard   try   BCrypt . verify ( message :   MyPassword ,   matches :   result )   else   { \n     fatalError ( This never triggers, since the verification process will always be successful for the same password and conditions )  }   The default cost factor is  12 , based on the official recommendations.", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-derived-key-as-a-string", 
            "text": "BCrypt always outputs valid ASCII/UTF-8 for the resulting hash.  This means you can convert the output  Data  to a  String  as such:  guard   let   string   =   String ( bytes :   result ,   encoding :   . utf8 )   else   { \n     // This must never trigger  }", 
            "title": "Storing the derived key as a String"
        }, 
        {
            "location": "/crypto/passwords/#pbkdf2", 
            "text": "PBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.  PBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.  For PBKDF2 you also select the Hash using generics.", 
            "title": "PBKDF2"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key_1", 
            "text": "In the following example:   password  is either a  String  or  Data  The  salt  is  Data  Iterations is defaulted to  10_000  iterations  The keySize is equivalent to 1 hash's length.   // Generate a random salt  let   salt :   Data   =   OSRandom (). data ( count :   32 )  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt )   You can optionally configure PBKDF2 to use a different iteration count and output keysize.  // Iterates 20 000 times and outputs 100 bytes  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt ,   iterating :   20_000 ,   derivedKeyLength :   100 )", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-results", 
            "text": "When you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Storing the results"
        }, 
        {
            "location": "/crypto/random/", 
            "text": "Random\n\n\nCrypto has two primary random number generators.\n\n\nOSRandom generates random numbers by calling the operating system's random number generator.\n\n\nURandom generates random numbers by reading from \n/dev/urandom\n.\n\n\nAccessing random numbers\n\n\nFirst, create an instance of the preferred random number generator:\n\n\nlet\n \nrandom\n \n=\n \nOSRandom\n()\n\n\n\n\n\n\nor\n\n\nlet\n \nrandom\n \n=\n \ntry\n \nURandom\n()\n\n\n\n\n\n\nReading integers\n\n\nFor every Swift integer a random number function exists.\n\n\nlet\n \nint8\n:\n \nInt8\n \n=\n \ntry\n \nrandom\n.\nmakeInt8\n()\n\n\nlet\n \nuint8\n:\n \nUInt8\n \n=\n \ntry\n \nrandom\n.\nmakeUInt8\n()\n\n\nlet\n \nint16\n:\n \nInt16\n \n=\n \ntry\n \nrandom\n.\nmakeInt16\n()\n\n\nlet\n \nuint16\n:\n \nUInt16\n \n=\n \ntry\n \nrandom\n.\nmakeUInt16\n()\n\n\nlet\n \nint32\n:\n \nInt32\n \n=\n \ntry\n \nrandom\n.\nmakeInt32\n()\n\n\nlet\n \nuint32\n:\n \nUInt32\n \n=\n \ntry\n \nrandom\n.\nmakeUInt32\n()\n\n\nlet\n \nint64\n:\n \nInt64\n \n=\n \ntry\n \nrandom\n.\nmakeInt64\n()\n\n\nlet\n \nuint64\n:\n \nUInt64\n \n=\n \ntry\n \nrandom\n.\nmakeUInt64\n()\n\n\nlet\n \nint\n:\n \nInt\n \n=\n \ntry\n \nrandom\n.\nmakeInt\n()\n\n\nlet\n \nuint\n:\n \nUInt\n \n=\n \ntry\n \nrandom\n.\nmakeUInt\n()\n\n\n\n\n\n\nReading random data\n\n\nRandom buffers of data are useful when, for example, generating tokens or other unique strings/blobs.\n\n\nTo generate a buffer of random data:\n\n\n// generates 20 random bytes\n\n\nlet\n \ndata\n:\n \nData\n \n=\n \nrandom\n.\ndata\n(\ncount\n:\n \n20\n)", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#random", 
            "text": "Crypto has two primary random number generators.  OSRandom generates random numbers by calling the operating system's random number generator.  URandom generates random numbers by reading from  /dev/urandom .", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#accessing-random-numbers", 
            "text": "First, create an instance of the preferred random number generator:  let   random   =   OSRandom ()   or  let   random   =   try   URandom ()", 
            "title": "Accessing random numbers"
        }, 
        {
            "location": "/crypto/random/#reading-integers", 
            "text": "For every Swift integer a random number function exists.  let   int8 :   Int8   =   try   random . makeInt8 ()  let   uint8 :   UInt8   =   try   random . makeUInt8 ()  let   int16 :   Int16   =   try   random . makeInt16 ()  let   uint16 :   UInt16   =   try   random . makeUInt16 ()  let   int32 :   Int32   =   try   random . makeInt32 ()  let   uint32 :   UInt32   =   try   random . makeUInt32 ()  let   int64 :   Int64   =   try   random . makeInt64 ()  let   uint64 :   UInt64   =   try   random . makeUInt64 ()  let   int :   Int   =   try   random . makeInt ()  let   uint :   UInt   =   try   random . makeUInt ()", 
            "title": "Reading integers"
        }, 
        {
            "location": "/crypto/random/#reading-random-data", 
            "text": "Random buffers of data are useful when, for example, generating tokens or other unique strings/blobs.  To generate a buffer of random data:  // generates 20 random bytes  let   data :   Data   =   random . data ( count :   20 )", 
            "title": "Reading random data"
        }, 
        {
            "location": "/routing/basics/", 
            "text": "Basics\n\n\nIn Vapor the default Router is the \nTrieRouter\n. You can implement custom routers by implementing one conformant to the \nRouter\n protocol.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \napp\n.\nmake\n(\nRouter\n.\nself\n)\n\n\n\n\n\n\nThere are two APIs available, one is supplied by the \nRouting\n library and a set of helpers is available in Vapor itself.\n\n\nRegistering a route using Routing\n\n\nThe \non\n function on a \nAsyncRouter\n registers a route to the provided path. The following registers a \nGET /hello/world\n route.\n\n\nIt responds with \n\"Hello world!\"\n using futures.\n\n\nrouter\n.\non\n(.\nget\n,\n \nto\n:\n \nhello\n,\n \nworld\n)\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nFuture\n(\ntry\n \nResponse\n(\nbody\n:\n \nHello world!\n))\n\n\n}\n\n\n\n\n\n\nThe \n.get\n represents the \nMethod\n you want to use. \nto: \"hello\", \"world\"\n registers the path \n/hello/world\n.\n\n\nFor variable path components you can use \nparameters\n.\n\n\nThe trailing closure receives a \nRequest\n. The route can throw errors and needs to return a \nFuture\nResponseRepresentable\n conforming type.\n\n\nRegistering a route using Vapor\n\n\nIn Vapor we add support for routes using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands.\n\n\nFor variable path components you can use \nparameters\n here, too.\n\n\nVapor has an added benefit here in that you can return the \nResponse\n itself in addition to \nFuture\nResponseRepresentable\n or \nFuture\nResponse\n.\n\n\ndrop\n.\nget\n(\ncomponents\n,\n \nin\n,\n \npath\n)\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}", 
            "title": "Basics"
        }, 
        {
            "location": "/routing/basics/#basics", 
            "text": "In Vapor the default Router is the  TrieRouter . You can implement custom routers by implementing one conformant to the  Router  protocol.  let   router   =   try   app . make ( Router . self )   There are two APIs available, one is supplied by the  Routing  library and a set of helpers is available in Vapor itself.", 
            "title": "Basics"
        }, 
        {
            "location": "/routing/basics/#registering-a-route-using-routing", 
            "text": "The  on  function on a  AsyncRouter  registers a route to the provided path. The following registers a  GET /hello/world  route.  It responds with  \"Hello world!\"  using futures.  router . on (. get ,   to :   hello ,   world )   {   request   in \n   return   Future ( try   Response ( body :   Hello world! ))  }   The  .get  represents the  Method  you want to use.  to: \"hello\", \"world\"  registers the path  /hello/world .  For variable path components you can use  parameters .  The trailing closure receives a  Request . The route can throw errors and needs to return a  Future ResponseRepresentable  conforming type.", 
            "title": "Registering a route using Routing"
        }, 
        {
            "location": "/routing/basics/#registering-a-route-using-vapor", 
            "text": "In Vapor we add support for routes using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands.  For variable path components you can use  parameters  here, too.  Vapor has an added benefit here in that you can return the  Response  itself in addition to  Future ResponseRepresentable  or  Future Response .  drop . get ( components ,   in ,   path )   {   request   in \n   return   Response ( status :   . ok )  }", 
            "title": "Registering a route using Vapor"
        }, 
        {
            "location": "/routing/parameters/", 
            "text": "Parameters\n\n\nParameters are a registered type that can be initialized from a String.\n\n\nThey can be part of a \nRoute\n, and be extracted from \nRequests\n that are called in that Route.\n\n\nCreating custom parameters\n\n\nTo create a custom parameter type, simply conform to \nParameter\n and implement the conversion function \nmake\n and a unique slug.\n\n\nIn this example, the \nUser\n class will be initialized from a parameter that represents it's identifier.\n\n\nWe recommend prefixing custom Parameter identifiers.\n\n\nclass\n \nUser\n \n:\n \nParameter\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n\n  \n// The unique (prefixed) identifier for this type\n\n  \nstatic\n \nvar\n \nuniqueSlug\n \n=\n \nmy-app:user\n\n\n  \n// Creates a new user from the raw `parameter`\n\n  \nstatic\n \nfunc\n \nmake\n(\nfor\n \nparameter\n:\n \nString\n,\n \nin\n \nrequest\n:\n \nRequest\n)\n \nthrows\n \n-\n \nUser\n \n{\n\n    \nreturn\n \nUser\n(\nnamed\n:\n \nparameter\n)\n\n  \n}\n\n\n  \ninit\n(\nnamed\n \nusername\n:\n \nString\n)\n \n{\n\n    \nself\n.\nusername\n \n=\n \nusername\n\n  \n}\n\n\n}\n\n\n\n\n\n\nUsing (custom) parameters\n\n\nAfter conforming a type to \nParameter\n you can access it's static property \nparameter\n as part of a path.\n\n\nrouter\n.\non\n(.\nget\n,\n \nto\n:\n \nusers\n,\n \nUser\n.\nparameter\n,\n \nprofile\n)\n \n{\n \nrequest\n \nin\n\n  \nlet\n \nuser\n \n=\n \ntry\n \nrequest\n.\nparameters\n.\nnext\n(\nUser\n.\nself\n)\n\n\n  \n// Return the user\ns Profile sync or async (depending on the router)\n\n\n}", 
            "title": "Parameters"
        }, 
        {
            "location": "/routing/parameters/#parameters", 
            "text": "Parameters are a registered type that can be initialized from a String.  They can be part of a  Route , and be extracted from  Requests  that are called in that Route.", 
            "title": "Parameters"
        }, 
        {
            "location": "/routing/parameters/#creating-custom-parameters", 
            "text": "To create a custom parameter type, simply conform to  Parameter  and implement the conversion function  make  and a unique slug.  In this example, the  User  class will be initialized from a parameter that represents it's identifier.  We recommend prefixing custom Parameter identifiers.  class   User   :   Parameter   { \n   var   username :   String \n\n   // The unique (prefixed) identifier for this type \n   static   var   uniqueSlug   =   my-app:user \n\n   // Creates a new user from the raw `parameter` \n   static   func   make ( for   parameter :   String ,   in   request :   Request )   throws   -   User   { \n     return   User ( named :   parameter ) \n   } \n\n   init ( named   username :   String )   { \n     self . username   =   username \n   }  }", 
            "title": "Creating custom parameters"
        }, 
        {
            "location": "/routing/parameters/#using-custom-parameters", 
            "text": "After conforming a type to  Parameter  you can access it's static property  parameter  as part of a path.  router . on (. get ,   to :   users ,   User . parameter ,   profile )   {   request   in \n   let   user   =   try   request . parameters . next ( User . self ) \n\n   // Return the user s Profile sync or async (depending on the router)  }", 
            "title": "Using (custom) parameters"
        }, 
        {
            "location": "/routing/route/", 
            "text": "Route\n\n\nRoute is an object that contains the essential information of an HTTP Route.\n\n\nIt contains the route's Method, path components and responder.\n\n\nExtensions\n\n\nRoutes are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nThe purpose is to allow tools (such as documentation tools) to hook into the Vapor routing process.", 
            "title": "Route"
        }, 
        {
            "location": "/routing/route/#route", 
            "text": "Route is an object that contains the essential information of an HTTP Route.  It contains the route's Method, path components and responder.", 
            "title": "Route"
        }, 
        {
            "location": "/routing/route/#extensions", 
            "text": "Routes are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.  The purpose is to allow tools (such as documentation tools) to hook into the Vapor routing process.", 
            "title": "Extensions"
        }, 
        {
            "location": "/routing/router/", 
            "text": "Router\n\n\nRouter is a protocol that you can conform your own routers to.\n\n\nRegistering a route\n\n\nFirst, create a \nRoute\n using a \nMethod\n, path and a responder.\n\n\nThe following example shows an \nasync route\n with a constant path.\n\n\nlet\n \nresponder\n \n=\n \nBasicAsyncResponder\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nFuture\n(\nHello world\n)\n\n\n}\n\n\n\nlet\n \nroute\n \n=\n \nRoute\n(\nmethod\n:\n \n.\nget\n,\n \npath\n:\n \n[.\nconstant\n(\nhello\n),\n \n.\nconstant\n(\nworld\n)],\n \nresponder\n:\n \nresponder\n)\n\n\n\n\n\n\nThe following example shows a \nsynchronous route\n with a \nParameter\n:\n\n\nlet\n \nresponder\n \n=\n \nBasicSyncResponder\n \n{\n \nrequest\n \nin\n\n  \nlet\n \nname\n \n=\n \ntry\n \nrequest\n.\nparameters\n.\nnext\n(\nString\n.\nself\n)\n\n  \nreturn\n \nHello \n\\(\nname\n)\n\n\n}\n\n\n\nlet\n \nroute\n \n=\n \nRoute\n(\nmethod\n:\n \n.\nget\n,\n \npath\n:\n \n[.\nconstant\n(\ngreet\n),\n \n.\nparameter\n(\nString\n.\nself\n)],\n \nresponder\n:\n \nresponder\n)\n\n\n\n\n\n\nRouting a request through a Router\n\n\nAssuming you have a request, like the following example:\n\n\nlet\n \nrequest\n \n=\n \nRequest\n(\nmethod\n:\n \n.\nget\n,\n \nURI\n(\npath\n:\n \n/hello/world\n))\n\n\n\n\n\n\nThe router should be able to route the \nRequest\n using\n\n\nlet\n \nresponder\n \n=\n \nrouter\n.\nroute\n(\nrequest\n:\n \nrequest\n)", 
            "title": "Router"
        }, 
        {
            "location": "/routing/router/#router", 
            "text": "Router is a protocol that you can conform your own routers to.", 
            "title": "Router"
        }, 
        {
            "location": "/routing/router/#registering-a-route", 
            "text": "First, create a  Route  using a  Method , path and a responder.  The following example shows an  async route  with a constant path.  let   responder   =   BasicAsyncResponder   {   request   in \n   return   Future ( Hello world )  }  let   route   =   Route ( method :   . get ,   path :   [. constant ( hello ),   . constant ( world )],   responder :   responder )   The following example shows a  synchronous route  with a  Parameter :  let   responder   =   BasicSyncResponder   {   request   in \n   let   name   =   try   request . parameters . next ( String . self ) \n   return   Hello  \\( name )  }  let   route   =   Route ( method :   . get ,   path :   [. constant ( greet ),   . parameter ( String . self )],   responder :   responder )", 
            "title": "Registering a route"
        }, 
        {
            "location": "/routing/router/#routing-a-request-through-a-router", 
            "text": "Assuming you have a request, like the following example:  let   request   =   Request ( method :   . get ,   URI ( path :   /hello/world ))   The router should be able to route the  Request  using  let   responder   =   router . route ( request :   request )", 
            "title": "Routing a request through a Router"
        }, 
        {
            "location": "/sockets/", 
            "text": "Using Sockets\n\n\nSockets is a library containing all Socket related APIs.\n\n\nIndex\n\n\n\n\nTCP Socket\n\n\nTCP Client\n\n\nTCP Server\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nSockets\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/sockets.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nSockets\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Sockets\n to access Sockets's APIs.", 
            "title": "Index"
        }, 
        {
            "location": "/sockets/#using-sockets", 
            "text": "Sockets is a library containing all Socket related APIs.", 
            "title": "Using Sockets"
        }, 
        {
            "location": "/sockets/#index", 
            "text": "TCP Socket  TCP Client  TCP Server", 
            "title": "Index"
        }, 
        {
            "location": "/sockets/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Sockets", 
            "title": "With Vapor"
        }, 
        {
            "location": "/sockets/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/sockets.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Sockets ,   ...   ]) \n     ]  )   Use  import Sockets  to access Sockets's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/sockets/tcp-client/", 
            "text": "TCP Clients\n\n\nSockets are a connection to another endpoint. They're usually connected to the internet, but may also run over a VPN or the local loopback (to your own computer). Sockets in Vapor currently only support asynchronous TCP sockets.\n\n\nCreating and connecting a socket\n\n\nThe first step is to create a new socket.\n\n\nlet\n \nsocket\n \n=\n \ntry\n \nSocket\n()\n\n\n\n\n\n\nThis socket is not connected to anything yet. To connect it you need to call the \nconnect\n function with a hostname and port.\n\n\ntry\n \nsocket\n.\nconnect\n(\nhostname\n:\n \nexample.com\n,\n \nport\n:\n \n80\n)\n\n\n\n\n\n\nAfter connecting, your socket may not be ready yet. Since this socket is asynchronous, the \nconnect\n phase may not be over yet.\n\n\nYou'll have to add a \nwritable\n notification to a queue. This queue \nmust\n be the current queue you're working on. \nMore about this here.\n\n\nlet\n \nconnectedNotification\n \n=\n \ntry\n \nsocket\n.\nwritable\n(\nqueue\n:\n \nworker\n.\nqueue\n)\n \n// Future\nVoid\n\n\n\n\n\n\nAt this point, a successful client socket has been created. You can either \ninteract with sockets manually\n or continue using the \nTCPClient\n helpers. In the second case, continue reading this article and wrap the socket.\n\n\nlet\n \nclient\n \n=\n \nTCPClient\n(\nsocket\n:\n \nsocket\n,\n \nworker\n:\n \nworker\n)\n\n\n\n\n\n\nCommunicating\n\n\nNow that your socket is connected you can start communicating. First, you'll need to start by setting up the handlers for incoming data.\n\n\nSince \nTCPClient\n is a stream, you can use \nthe introduction\n and \nthe basics\n of streams for reading the socket's output (incoming data).\n\n\nSending data is done through the \ninputStream\n function.\n\n\nclient\n.\ninputStream\n(\ndata\n)\n \n// Sends `Data`\n\n\n\n\n\n\nThis accepts \nByteBuffer\n, \nData\n and \nDispatchData\n. Chaining streams into this \nTCPClient\n, however, requires a \nByteBuffer\n.\n\n\nOnce your client is all set up, \nstart()\n reading.\n\n\nclient\n.\nstart\n()", 
            "title": "TCP Client"
        }, 
        {
            "location": "/sockets/tcp-client/#tcp-clients", 
            "text": "Sockets are a connection to another endpoint. They're usually connected to the internet, but may also run over a VPN or the local loopback (to your own computer). Sockets in Vapor currently only support asynchronous TCP sockets.", 
            "title": "TCP Clients"
        }, 
        {
            "location": "/sockets/tcp-client/#creating-and-connecting-a-socket", 
            "text": "The first step is to create a new socket.  let   socket   =   try   Socket ()   This socket is not connected to anything yet. To connect it you need to call the  connect  function with a hostname and port.  try   socket . connect ( hostname :   example.com ,   port :   80 )   After connecting, your socket may not be ready yet. Since this socket is asynchronous, the  connect  phase may not be over yet.  You'll have to add a  writable  notification to a queue. This queue  must  be the current queue you're working on.  More about this here.  let   connectedNotification   =   try   socket . writable ( queue :   worker . queue )   // Future Void   At this point, a successful client socket has been created. You can either  interact with sockets manually  or continue using the  TCPClient  helpers. In the second case, continue reading this article and wrap the socket.  let   client   =   TCPClient ( socket :   socket ,   worker :   worker )", 
            "title": "Creating and connecting a socket"
        }, 
        {
            "location": "/sockets/tcp-client/#communicating", 
            "text": "Now that your socket is connected you can start communicating. First, you'll need to start by setting up the handlers for incoming data.  Since  TCPClient  is a stream, you can use  the introduction  and  the basics  of streams for reading the socket's output (incoming data).  Sending data is done through the  inputStream  function.  client . inputStream ( data )   // Sends `Data`   This accepts  ByteBuffer ,  Data  and  DispatchData . Chaining streams into this  TCPClient , however, requires a  ByteBuffer .  Once your client is all set up,  start()  reading.  client . start ()", 
            "title": "Communicating"
        }, 
        {
            "location": "/security/", 
            "text": "Security\n\n\nSecurity is a critical part of any software and comes in many forms. Denial of Service attacks and code injection are only the tip of the iceberg.\nIt is always important to understand some basics of security. Vapor 3 is designed to be secure by default, but anything you build on top of Vapor 3 might not be.\n\n\nRecommended information\n\n\n\n\nPassword management\n\n\nJWT (Session) Tokens\n\n\n\n\nAdditional information\n\n\n\n\nDenial of Service prevention", 
            "title": "Index"
        }, 
        {
            "location": "/security/#security", 
            "text": "Security is a critical part of any software and comes in many forms. Denial of Service attacks and code injection are only the tip of the iceberg.\nIt is always important to understand some basics of security. Vapor 3 is designed to be secure by default, but anything you build on top of Vapor 3 might not be.", 
            "title": "Security"
        }, 
        {
            "location": "/security/#recommended-information", 
            "text": "Password management  JWT (Session) Tokens", 
            "title": "Recommended information"
        }, 
        {
            "location": "/security/#additional-information", 
            "text": "Denial of Service prevention", 
            "title": "Additional information"
        }, 
        {
            "location": "/security/dos/", 
            "text": "Denial of Service\n\n\nDenial of Service attacks are common and often easy to execute. They come in a few major categories.\nMost of the attacks can be countered by an application. This document outlines how Vapor 3 is designed against these attacks and how you can make use of the tools available.\n\n\nMemory buffer attacks\n\n\nMemory buffer attacks are achieved by draining the amount of memory a server has available.\n\n\nOne example in HTTP/1 is by sending an arbitrarily large POST data containing any data. The server might accept the data for an indefinite period of time causing the memory to fill up and the application to meet the hardware or virtual machine limits. This can cause swapping, a crash or both.\n\n\nA second example exploits the same principle in WebSockets, where the protocol allows sending data up to \nUInt64.max\n.\n\n\nSolution 1\n\n\nLimit the maximum amount of data on protocol level, rejecting any requests exceeding the limit. The follow-up behaviour of the server can be either closing the connection or returning a \"Bad Request\" response.\n\n\nSolution 2\n\n\nHTTP/2 is a protocol designed against these attacks. Hosting HTTP/2 as the protocol of choice can improve performance and reduce attack vectors in many ways.\n\n\nSolution 3\n\n\nNGINX is commonly used as a proxy between the public internet and an application such as a Vapor based application. Setting up a \"reverse-proxy\" can prevent a lot of attacks before they reach your application server.\n\n\nOpening many of connections\n\n\nOpening many (hundreds or thousands) connections to a server is really heavy. There are two attacks that can follow.\n\n\n\n\nSending a lot of data really quickly\n\n\nSending very little data, very slowly.\n\n\n\n\nThe first attack targets network bandwidth, and the second attack targets the CPU.\n\n\nBoth are (partially) prevented by default using the \nPeerValidator\n which is part of the \nServerSecurity\n module which is included with the Vapor framework. It is enabled by default as part of the \nEngineServer\n but needs to be added manually for other HTTP servers.\n\n\nHow PeerValidator works\n\n\nAs part of Vapor 3's design goals, all notification-like I/O is implemented using \nStreams\n. This also includes the \nTCP Server\n. The TCP server is seen as a stream of clients/peers that are accepted and then sent to the client. It has a hook called \nwillAccept\n. This closure's input is a \nTCPClient\n, and the output is a \nBool\n. If the returned boolean is \ntrue\n, the peer will be accepted where \nfalse\n will deny the peer and will close the connection.\n\n\nPeerValidator\n hooks into this capability by looking the peer's address up in it's cache and keeps track of the amount of connections this peer has currently opened to this server. If the counter exceeds a threshold as specified in the \nPeerValidator\n initializer, the connection will be rejected.\n\n\nUsing PeerValidator\n\n\nPeerValidator's \nwillAccept\n function can be hooked into the TCPServer's \nwillAccept\n.\n\n\nlet\n \nvalidator\n \n=\n \nPeerValidator\n(\nmaxConnectionsPerIP\n:\n \n100\n)\n\n\n\ntcpServer\n.\nwillAccept\n \n=\n \nvalidator\n.\nwillAccept", 
            "title": "Denial of Service"
        }, 
        {
            "location": "/security/dos/#denial-of-service", 
            "text": "Denial of Service attacks are common and often easy to execute. They come in a few major categories.\nMost of the attacks can be countered by an application. This document outlines how Vapor 3 is designed against these attacks and how you can make use of the tools available.", 
            "title": "Denial of Service"
        }, 
        {
            "location": "/security/dos/#memory-buffer-attacks", 
            "text": "Memory buffer attacks are achieved by draining the amount of memory a server has available.  One example in HTTP/1 is by sending an arbitrarily large POST data containing any data. The server might accept the data for an indefinite period of time causing the memory to fill up and the application to meet the hardware or virtual machine limits. This can cause swapping, a crash or both.  A second example exploits the same principle in WebSockets, where the protocol allows sending data up to  UInt64.max .", 
            "title": "Memory buffer attacks"
        }, 
        {
            "location": "/security/dos/#solution-1", 
            "text": "Limit the maximum amount of data on protocol level, rejecting any requests exceeding the limit. The follow-up behaviour of the server can be either closing the connection or returning a \"Bad Request\" response.", 
            "title": "Solution 1"
        }, 
        {
            "location": "/security/dos/#solution-2", 
            "text": "HTTP/2 is a protocol designed against these attacks. Hosting HTTP/2 as the protocol of choice can improve performance and reduce attack vectors in many ways.", 
            "title": "Solution 2"
        }, 
        {
            "location": "/security/dos/#solution-3", 
            "text": "NGINX is commonly used as a proxy between the public internet and an application such as a Vapor based application. Setting up a \"reverse-proxy\" can prevent a lot of attacks before they reach your application server.", 
            "title": "Solution 3"
        }, 
        {
            "location": "/security/dos/#opening-many-of-connections", 
            "text": "Opening many (hundreds or thousands) connections to a server is really heavy. There are two attacks that can follow.   Sending a lot of data really quickly  Sending very little data, very slowly.   The first attack targets network bandwidth, and the second attack targets the CPU.  Both are (partially) prevented by default using the  PeerValidator  which is part of the  ServerSecurity  module which is included with the Vapor framework. It is enabled by default as part of the  EngineServer  but needs to be added manually for other HTTP servers.", 
            "title": "Opening many of connections"
        }, 
        {
            "location": "/security/dos/#how-peervalidator-works", 
            "text": "As part of Vapor 3's design goals, all notification-like I/O is implemented using  Streams . This also includes the  TCP Server . The TCP server is seen as a stream of clients/peers that are accepted and then sent to the client. It has a hook called  willAccept . This closure's input is a  TCPClient , and the output is a  Bool . If the returned boolean is  true , the peer will be accepted where  false  will deny the peer and will close the connection.  PeerValidator  hooks into this capability by looking the peer's address up in it's cache and keeps track of the amount of connections this peer has currently opened to this server. If the counter exceeds a threshold as specified in the  PeerValidator  initializer, the connection will be rejected.", 
            "title": "How PeerValidator works"
        }, 
        {
            "location": "/security/dos/#using-peervalidator", 
            "text": "PeerValidator's  willAccept  function can be hooked into the TCPServer's  willAccept .  let   validator   =   PeerValidator ( maxConnectionsPerIP :   100 )  tcpServer . willAccept   =   validator . willAccept", 
            "title": "Using PeerValidator"
        }, 
        {
            "location": "/supplementary/architecture/", 
            "text": "TODO", 
            "title": "Architecture"
        }, 
        {
            "location": "/supplementary/performance/", 
            "text": "TODO", 
            "title": "Performance"
        }, 
        {
            "location": "/version/1_5/", 
            "text": "Redirecting...", 
            "title": "1.5"
        }, 
        {
            "location": "/version/1_5/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/2_0/", 
            "text": "Redirecting...", 
            "title": "2.0"
        }, 
        {
            "location": "/version/2_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/3_0/", 
            "text": "Redirecting...", 
            "title": "3.0-alpha"
        }, 
        {
            "location": "/version/3_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/support/", 
            "text": "Version Support\n\n\n\n\nVapor 3.0 is currently in beta.\n\n\nVapor 2.0 is currently active.\n\n\nVapor 1.5 is being maintained until November 2017.\n\n\n\n\nWarning\n\n\nDashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.\n\n\n\n\nCore\n\n\nAll packages in the \nVapor GitHub\n are maintained according to the following rules.\n\n\nActive\n\n\nWhile a version is active, reported security issues and bugs are fixed.\n\n\nAdditionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.\n\n\nMaintenance\n\n\nWhen a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.\n\n\n\n\nNote\n\n\nOnly the latest minor version will be maintained.\n\n\n\n\nUnstable\n\n\nThe master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.\n\n\nCommunity\n\n\nAll packages in the \nVapor Community GitHub\n are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Support"
        }, 
        {
            "location": "/version/support/#version-support", 
            "text": "Vapor 3.0 is currently in beta.  Vapor 2.0 is currently active.  Vapor 1.5 is being maintained until November 2017.   Warning  Dashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.", 
            "title": "Version Support"
        }, 
        {
            "location": "/version/support/#core", 
            "text": "All packages in the  Vapor GitHub  are maintained according to the following rules.", 
            "title": "Core"
        }, 
        {
            "location": "/version/support/#active", 
            "text": "While a version is active, reported security issues and bugs are fixed.  Additionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.", 
            "title": "Active"
        }, 
        {
            "location": "/version/support/#maintenance", 
            "text": "When a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.   Note  Only the latest minor version will be maintained.", 
            "title": "Maintenance"
        }, 
        {
            "location": "/version/support/#unstable", 
            "text": "The master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.", 
            "title": "Unstable"
        }, 
        {
            "location": "/version/support/#community", 
            "text": "All packages in the  Vapor Community GitHub  are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Community"
        }
    ]
}